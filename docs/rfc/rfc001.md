RFC-V4-001 (Final, Amended)

RawData → Slice → Virtual View → Direct Query (DynamoDB)
Contract-First Deterministic Data Runtime

Status: Final
Scope: v4 (Sync, DynamoDB-only)
Out-of-Scope: CDC / Sink / OpenSearch (v4.1+)

0. Executive Summary

본 RFC는 이커머스 마스터 데이터를 계약(Contract) 기반, 결정적·멱등적으로 처리하는 v4 런타임 아키텍처를 정의한다.

v4의 핵심:

RawData를 Contract 기반으로 DynamoDB에 저장

RuleSet 계약에 따라 결정적·멱등적으로 Slice 생성

ChangeSet 기반 증분 업데이트 지원

Slice 생성 시 제한적(Light) JOIN 허용

View는 물리 저장 없이 Virtual Join으로 조회

모든 결정의 SSOT는 version: Long

멱등성/결정성/오염 방지를 조건부 저장 + hash 검증으로 강제

SDK 노출은 View 기준 자동 코드젠

Sink(OpenSearch 등)는 v4.1에서 DynamoDB Streams 기반 CDC로 분리

v4는 동기·단순·fail-closed를 목표로 하며, 파이프라인/비동기/인덱싱은 의도적으로 배제한다.

1. Non-Negotiable Invariants (헌법)

1-1. Contract is Law
RawData / RuleSet / ViewDefinition은 계약이며, 런타임은 이를 기계적으로 집행한다.

1-2. version: Long is SSOT
모든 저장·슬라이싱·조회는 동일한 version: Long을 기준으로 한다.

1-3. Determinism
동일 입력은 항상 동일 Slice/View 결과를 생성해야 한다.

1-4. Idempotency
동일 key/version 재실행은 부작용 없이 동일 결과를 반환해야 한다.

1-5. Fail-Closed by Default
계약 불일치, Slice 누락, 상태 위반은 기본 오류다.

1-6. View is Read-Only
View 조회는 상태 변경을 유발하지 않는다.

1-7. Join Boundary is Explicit
JOIN은 Slice 생성 단계에서만 제한적으로 허용되며, View에서는 재계산하지 않는다.

2. Scope Definition
2-1. In-Scope (v4)

insertRawdata()

createChangeSet()

slicing() (FULL / INCREMENTAL)

queryView()

DynamoDB RawData / Slice / ChangeSet 저장·조회

Contract Registry 로딩/검증

결정성·멱등성·불변식 강제

Slice 생성 시 Light JOIN

2-2. Out-of-Scope (v4)

OpenSearch / 인덱싱 Sink

DynamoDB 구독 / CDC

비동기 워커 / Outbox

ActiveVersion Resolver

UI / 운영 콘솔

3. Core Concepts (추가)

3-1. ChangeSet
RawData 버전 간 차이를 계약 기반으로 정규화한 변경 집합이며, 증분 업데이트의 SSOT다.

3-2. ImpactedSliceSet
ChangeSet + RuleSet으로부터 계산되는 “재생성 대상 Slice 집합”.

3-3. Light JOIN
Slice 생성 시 다른 Entity의 RawData/Slice를 읽기 전용으로 참조하여 일부 필드를 포함하는 제한적 JOIN.

4. Version Model (SSOT)
4-1. Data Version (version: Long)

entityKey 기준 단조 증가

동일 (tenantId, entityKey, version) 불변

FULL / INCREMENTAL slicing 모두 동일 version 기준

4-2. Contract Version (SemVer)

schemaVersion / ruleSetVersion / viewVersion

데이터 version과 독립

5. Contract Registry Policy

(기존 RFC와 동일, 변경 없음)

6. Key & Identity Rules

entityKey = {entityType}#{entityId}

RawKey는 반드시 entityKey를 포함

7. Storage Model (DynamoDB)
7-1. RawData Table

(기존 RFC와 동일)

7-2. Slice Table

(기존 RFC와 동일, 단 아래 추가)

tombstone: boolean
증분 업데이트 시 “삭제된 결과”를 표현하기 위한 논리적 삭제 플래그

7-3. ChangeSet Table (신규)

Table: changesets

PK: tenant_id

SK: entity_key#from_version#to_version

Attributes

from_version

to_version

rule_set_id

rule_set_version

changeset_payload

changeset_hash

created_at

불변성

동일 PK/SK 존재 시 hash 동일만 허용

8. Architecture (Hexagonal)
Domain

RawDataValidator

ChangeSetBuilder

SlicingEngine (Light JOIN 포함)

ViewJoiner

9. ChangeSet & Incremental Slicing (신규 핵심)
9-1. ChangeSet 생성

입력
(tenantId, entityKey, fromVersion, toVersion, schemaRef, ruleSetRef)

처리 순서

RawData(from) 로드

RawData(to) 로드

Schema 기반 canonical diff 생성

changeset_hash 계산

조건부 put

9-2. ImpactMap (RuleSet 필수 구성)

RuleSet은 반드시 다음을 선언해야 한다.

pathSelector → sliceType[]

Join으로 생성된 SliceType도 포함

매칭 실패 시 기본 정책

v4 기본: FAIL_CLOSED

9-3. slicing() 모드

FULL_REBUILD

INCREMENTAL(fromVersion)

INCREMENTAL 처리

ChangeSet 로드

ImpactMap으로 ImpactedSliceSet 계산

대상 SliceType만 재생성

slice_hash 조건부 put

결과 0건인 경우 tombstone 기록

불변식

FULL 결과 == INCREMENTAL 결과

10. Light JOIN at Slice Build (신규)
10-1. 허용 원칙

Slice 생성 단계에서만 허용

MANY_TO_ONE / ONE_TO_ONE만 허용

Join 결과는 Slice에 물리화

View에서 재조인 금지

10-2. JoinSpec (RuleSet 계약)

joinSources

entityType

keyResolver

versionRule (동일 version 기본)

joinProjection

포함 필드 명시

joinImpact

참조 엔티티 변경 시 영향 SliceType

명시되지 않은 Join 영향은 FAIL_CLOSED

11. Fan-out Strategy (증분·Join 대응 핵심)
11-1. Fan-out의 정의

Fan-out은 다음 두 지점에서 발생한다.

ChangeSet → 여러 SliceType으로 확산

Join 대상 변경 → 여러 부모 Entity Slice 재생성

11-2. v4 Fan-out 원칙

Fan-out은 데이터 파이프라인이 아니라 “계산된 키 집합”으로 표현

즉, “이벤트 브로드캐스트”가 아니라
ImpactedSliceKeySet을 결정적으로 계산한다.

11-3. Fan-out 계산 방식 (권장, v4)

ChangeSet 생성

RuleSet ImpactMap 평가

JoinSpec 영향 평가

결과를 다음 형태로 계산

ImpactedSliceKeySet = {
  (entityKey, version, sliceType) ...
}


slicing()은 이 key set을 순회하며 동기적으로 처리

특징

큐 / 이벤트 / 워커 없음

재시도는 동일 입력 재호출로 해결

fan-out 크기는 계약(ImpactMap/JoinSpec)으로 통제

11-4. Fan-out 확장성에 대한 명시적 제한

v4에서는 다음을 허용하지 않는다.

무제한 부모 탐색

역방향 그래프 조회

런타임 동적 fan-out 계산

이유

결정성 붕괴

DynamoDB scan 유도

v4 설계 목표 위반

대규모 fan-out은 v4.1에서

역참조 인덱스 Slice

Streams 기반 비동기 재빌드
로 분리한다.

12. ViewDefinition

(기존 RFC와 동일)

13. Error Model

(기존 RFC와 동일)

14. Testing Policy (Mandatory)

추가 항목

FULL vs INCREMENTAL 결과 동치 테스트

Join 대상 변경 시 영향 Slice 재생성 테스트

Fan-out 계산 결정성 테스트

15. DynamoDB Subscription / Sink Policy

15-1. v4

DynamoDB Streams 미사용

15-2. v4.1

Slice Table → Streams

Streams → OpenSearch / Sink

Fan-out은 CDC가 아닌 Slice 결과 기반

16. Final Judgment

이 RFC는 다음을 모두 만족한다.

Contract-First

Deterministic / Idempotent

ChangeSet 기반 증분 업데이트

Slice 생성 시 Light JOIN

Fan-out을 “계산된 키 집합”으로 통제

DynamoDB-only 동기 MVP

v4.1 확장 경로 명확

17. Inverted Index Key Rules (Final, SSOT)
17-1. 목적

Inverted Index Key는 다음을 위해 사용된다.

fan-out을 scan 없이 결정적으로 계산

Join 대상 변경 시 영향받는 부모 entity를 역으로 추적

v4.1 CDC / Sink(OpenSearch)에서 증분 재색인 단위를 최소화

중요 원칙

Inverted index는 조회 인덱스가 아니라 계산 보조 인덱스임

Domain 로직은 이를 옵션 입력으로만 사용하며, 없으면 fail-closed 또는 full rebuild로 폴백

17-2. Inverted Index의 위치와 성격

Inverted index는 Slice의 파생 산출물

RawData에는 직접 만들지 않음

Slice 생성 시 동시에 결정적으로 생성

즉:

RawData
  → Slice
    → InvertedIndexKey(s)

17-3. Inverted Index Key 기본 포맷

모든 inverted index key는 아래 SSOT 포맷을 따른다.

IDX#{index_type}#{index_value}#{entity_type}


예시

IDX#brand#B77#product
IDX#category#C12#product
IDX#status#ACTIVE#product


불변식

동일 Slice 입력 → 동일 index key 집합

index_value는 반드시 canonicalized value

17-4. Inverted Index Table (DynamoDB)

Table: slice_inverted_index

PK: tenant_id

SK: index_key

Attributes

entity_key

version

slice_type

slice_hash

특징

한 index_key → 여러 entity_key 허용 (fan-out의 근원)

동일 (tenant, index_key, entity_key, version) 불변

17-5. RuleSet DSL 내 Inverted Index 선언 (필수)

Inverted index는 RuleSet 계약에서만 선언 가능하다.

17-5-1. DSL 예시
indexes:
  - type: brand
    fromSlice: PRODUCT_CORE
    selector:
      path: "brand_id"
    indexKey:
      format: "IDX#brand#{value}#product"

  - type: category
    fromSlice: PRODUCT_CORE
    selector:
      path: "category_ids[*]"
    indexKey:
      format: "IDX#category#{value}#product"

  - type: status
    fromSlice: PRODUCT_CORE
    selector:
      path: "status"
    indexKey:
      format: "IDX#status#{value}#product"


불변식

selector 결과는 반드시 canonical order로 정렬

indexKey format은 pure function

17-6. Inverted Index 생성 시점 (Chronological)
FULL_REBUILD

Slice 생성

Slice payload canonicalization

Index selector 평가

IndexKey 집합 계산

조건부 put (slice_hash 기준)

INCREMENTAL

ChangeSet → ImpactedSliceTypes 계산

영향 Slice만 재생성

해당 Slice에 연결된 index만 재계산

기존 index entry 제거 or tombstone

신규 index entry put

17-7. ChangeSet × Inverted Index 연동 규칙

ChangeSet → ImpactMap → ImpactedSliceTypes 이후:

SliceType이 index source인 경우

반드시 inverted index도 재계산

SliceType이 index source가 아니면

index 변경 금지

즉, Index fan-out은 Slice fan-out의 하위 집합임.

17-8. Join + Inverted Index 연동

Join으로 생성된 Slice도 index source가 될 수 있다.

예시

PRODUCT_BRAND_ENRICHED slice

brand_name 기반 검색/필터를 위해 index 생성

이 경우 RuleSet은 반드시 선언해야 한다.

indexes:
  - type: brand_name
    fromSlice: PRODUCT_BRAND_ENRICHED
    selector:
      path: "brand_name"
    indexKey:
      format: "IDX#brand_name#{value}#product"


Join 대상 변경 시:

ChangeSet(brand)

→ JoinSpec impact

→ PRODUCT_BRAND_ENRICHED 재생성

→ 해당 index 재생성

17-9. Fan-out에서 Inverted Index의 역할
v4 Fan-out 계산 흐름

ChangeSet 생성

ImpactMap → ImpactedSliceTypes

JoinSpec 영향 반영

필요 시 inverted index 조회

index_value → entity_key 목록

ImpactedSliceKeySet 결정

중요

index 조회는 key 기반 get/query만 허용

scan 금지

index가 없으면 fail-closed 또는 full rebuild

17-10. 명시적 제한 (Non-Goals)

v4에서 inverted index는 다음을 하지 않는다.

full-text search

ranking

scoring

relevance 계산

이는 v4.1 Sink(OpenSearch)의 책임이다.

17-11. Testing Invariants

동일 Slice → 동일 index key 집합

FULL_REBUILD index == INCREMENTAL index

Join 변경 → index 재계산 동치성

index 누락 시 fail-closed 동작
