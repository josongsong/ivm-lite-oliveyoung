RFC-V4-002

Determinism & Safety Enforcement Layer
Canonicalization · Hashing · Conflict · Tombstone · Ordering

Status: Final
Scope: v4 Library Mandatory Rules
Applies to: RFC-V4-001 전 영역
Non-Goals: 기능 추가, API 확장

0. 목적 (Why this RFC exists)

RFC-V4-001은 구조적으로 완결된 런타임 아키텍처를 정의한다.
하지만 라이브러리 관점에서 다음 질문들이 명시적으로 고정되지 않으면 운영 불가능하다.

“같은 데이터”의 기준은 무엇인가

hash가 다르면 언제 버그인가

tombstone은 무엇을 의미하는가

fan-out 순서가 결과에 영향을 주지 않는가

어떤 오류는 재시도해도 되는가

본 RFC는 위 질문에 대한 답을 코드가 아니라 규칙(SSOT) 으로 고정한다.

1. Canonicalization Rules (SSOT)
1-1. Canonical JSON 규칙

모든 hash 계산 대상(JSON)은 RFC 8785 Canonical JSON을 따른다.

강제 규칙

Object key: lexicographical sort

Number: 정규화 표현 (1 ≠ 1.0)

Boolean/null: JSON 표준 그대로

Whitespace: 제거

Array: 순서 보존, 단 DSL에서 명시된 경우에만 정렬 허용

1-2. Canonicalization 적용 대상

RawData payload

Slice payload

ChangeSet payload

Join 결과 중 projection payload

Inverted index selector 결과

Canonicalization 없이 hash 계산 금지.

2. Hashing Rules (SSOT)
2-1. Hash 알고리즘

SHA-256 고정

Salt 사용 금지

2-2. Hash 입력 범위 고정

RawData

raw_hash = SHA256(
  canonical(raw_payload)
  + schema_id
  + schema_version
)


Slice

slice_hash = SHA256(
  canonical(slice_payload)
  + ruleset_id
  + ruleset_version
)


ChangeSet

changeset_hash = SHA256(
  canonical(diff_ops)
  + from_version
  + to_version
  + ruleset_id
  + ruleset_version
)

2-3. Hash 불일치 의미

동일 key/version에서 hash 불일치 = InvariantViolation

재시도 불가

운영자 개입 대상

3. Conflict & InvariantViolation 분류
3-1. 재시도 불가 오류 (Hard Failure)

아래는 라이브러리 버그 또는 데이터 오염이다.

동일 (tenant, entityKey, version)에서 payload_hash 다름

동일 slice key에서 slice_hash 다름

FULL_REBUILD ≠ INCREMENTAL 결과

동일 ChangeSet 재적용 결과 불일치

→ 즉시 실패, 재시도 금지

3-2. 재시도 가능 오류 (Soft Failure)

DynamoDB ConditionalCheckFailed (동시성)

네트워크 오류

일시적 timeout

→ 동일 입력으로 safe retry 가능

4. Deterministic Ordering Rules

다음 결과물은 항상 동일한 정렬 순서를 가져야 한다.

Slice 생성 결과 목록

ImpactedSliceKeySet

Inverted index key 목록

Fan-out 처리 대상 key 집합

정렬 규칙

lexicographical ascending

locale 영향 금지

정렬 결과가 hash 입력에 영향을 주지 않아야 함

5. Tombstone Semantics (SSOT)
5-1. Tombstone 정의

Tombstone Slice란:

“이 sliceType은 이 entityKey/version 조합에서 존재하지 않음”을
결정적으로 표현하는 데이터

5-2. Tombstone Slice 규칙

slice_payload = null

tombstone = true

slice_hash는 반드시 존재

5-3. View에서 Tombstone 처리

missingPolicy = FAIL_CLOSED
→ 즉시 오류

missingPolicy = PARTIAL_ALLOWED
→ 해당 slice 제외

5-4. Inverted Index와 Tombstone

tombstone slice → index entry 제거 또는 tombstone index

index 누락은 silent ignore 금지

6. Version Gap Policy
6-1. 기본 정책 (v4)

fromVersion → toVersion은 연속적이어야 함

gap 발견 시 fail-closed

예

허용: v3 → v4

금지: v3 → v7

6-2. 이유

ChangeSet 누락 방지

증분 결과의 신뢰성 보장

7. Multi-RuleSet Coexistence Rules
7-1. 허용 모델

동일 RawData version

서로 다른 RuleSet version

서로 다른 Slice namespace

7-2. 강제 규칙

Slice key는 ruleSet_version으로 완전 분리

ViewDefinition은 기대 RuleSet을 명시해야 함

암묵적 혼용 금지.

8. Clock & Metadata Injection
8-1. 원칙

Domain layer: 시간 개념 없음

Adapter layer에서만 시간 주입

8-2. 허용 메타데이터

ingested_at

sliced_at

indexed_at

결과 값에는 영향을 주지 않아야 함.

9. SDK Codegen Safety Rules
9-1. SDK에서 강제할 것

version 필수 인자

missingPolicy 반영

nullable 필드 명시적 표현

9-2. SDK에서 금지할 것

version 생략

partial 결과를 정상 결과처럼 반환

10. Safe Defaults (Library Mandatory)

모든 기본값은 보수적으로 설정된다.

missingPolicy = FAIL_CLOSED

ImpactMap onNoMatch = FAIL_CLOSED

Join missing = FAIL_CLOSED

Index missing = FAIL_CLOSED

사용자가 완화하려면 계약에서 명시해야 한다.

11. Minimal Observability Hooks

라이브러리는 다음 식별자를 외부로 노출할 수 있어야 한다.

decision_trace_id

slicing_id (hash 기반)

ruleset_id / ruleset_version

changeset_hash

형식은 비강제, 존재만 강제.

12. Explicit Non-Goals

이 라이브러리는 다음을 제공하지 않는다.

트랜잭션 보장

cross-entity consistency

search / ranking

realtime fan-out

background rebuild

이를 기대하는 사용은 설계 위반이다.

13. 최종 결론

RFC-V4-001이 구조적 설계의 헌법이라면,
RFC-V4-002는 그 설계를 “운영 가능한 라이브러리”로 만드는 집행 규약이다.

이 RFC 없이는:

결정성은 주장일 뿐이고

멱등성은 우연이며

운영은 불가능하다.

RFC-V4-002는 선택이 아니라 필수다.
