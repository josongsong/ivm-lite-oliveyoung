RFC-V4-003 (Final)

Contract Enhancement & DX Endgame
계약 보완 및 개발자 경험 완성

Status: Final
Scope: v4 / v4.1 (Contract Layer)
Depends on: RFC-V4-001, RFC-V4-002
Audience: Platform / SDK / Tooling / Contract Authors

0. Executive Summary

본 RFC는 v4/v4.1 아키텍처의 계약(Contract) 레이어를 보완하고, 개발자 경험(DX)을 "끝판" 수준으로 끌어올리는 설계를 정의한다.

핵심 목표:

계약에서 빠지기 쉬운 구멍을 정의로 봉인
계약 작성 → 타입/SDK 자동 생성 → 로컬 시뮬레이션 → 배포까지 원클릭
계약 변경 시 호환성 검증이 PR 단계에서 자동 차단
운영 입력(Replay/Backfill)도 계약으로만 허용

본 RFC는 RFC-V4-001의 계약 개념을 확장하여 실무에서 "실수할 수 없는" 수준의 DX를 보장한다.

1. 최종판 목표

1-1. 계약/테이블/레지스트리 방향 확정

현재 설계 방향:
- 계약(Contract) 기반 런타임 ✓
- 테이블 구조(Single Table Design) ✓
- 레지스트리(Policy/Schema 분리) ✓

이 방향은 유지하며, 계약 레이어를 보완한다.

1-2. DX 끝판 목표

"계약 작성하면 자동으로 타입/SDK 생성"부터 "운영 입력도 계약으로만"까지 전 과정을 계약 중심으로 설계한다.

1-3. v4/v4.1 확장 가능성

본 RFC의 계약 설계는 v4.1(CDC/Sink)까지 확장 가능하도록 설계한다.

2. 계약 보완 포인트 (필수 12개)

2-1. ContractRef 표준화 (전 계약 공통)

**문제**: 계약 참조가 문자열(`schemaId@1.2.0`)과 구조체가 혼재되어 일관성 부족.

**해결**: 모든 계약 참조를 아래 한 형태로 고정.

```kotlin
@JvmInline
value class ContractRef(
    val id: String,
    val version: SemVer
) {
    companion object {
        fun parse(ref: String): Either<ParseError, ContractRef> {
            // "schemaId@1.2.0" → ContractRef("schemaId", SemVer(1, 2, 0))
        }
        
        fun format(ref: ContractRef): String = "${ref.id}@${ref.version}"
    }
}
```

**규칙**:
- 문자열 `schemaId@1.2.0`도 지원하되, 내부 SSOT는 구조체
- 모든 계약 파일에서 `ContractRef` 사용 필수
- 파싱 실패 시 `ParseError` 반환 (fail-closed)

**적용 범위**:
- `schemaRef` (RuleSet)
- `ruleSetRef` (ViewDefinition, ChangeSet)
- `viewRef` (ReplayRequest)
- `outputSchemaRef` (Slice 정의)

---

2-2. ContractStatusGate 필수 (런타임 fail-closed)

**문제**: 계약 상태(DRAFT/ACTIVE/DEPRECATED/ARCHIVED) 검증이 런타임에서 누락되면 오염 발생.

**해결**: 런타임에서 계약 로드 시 상태 검증 필수.

```kotlin
sealed interface ContractStatus {
    object DRAFT : ContractStatus
    object ACTIVE : ContractStatus
    object DEPRECATED : ContractStatus
    object ARCHIVED : ContractStatus
}

interface ContractStatusGate {
    fun allow(status: ContractStatus, override: ContractStatusOverride?): Either<StatusGateError, Unit>
}

// 기본 정책
object DefaultContractStatusGate : ContractStatusGate {
    override fun allow(status: ContractStatus, override: ContractStatusOverride?): Either<StatusGateError, Unit> = when (status) {
        is ContractStatus.ACTIVE -> Unit.right()
        is ContractStatus.DEPRECATED -> {
            when (override) {
                is ContractStatusOverride.AllowDeprecated -> {
                    logger.warn { "Using DEPRECATED contract: ${override.ref}" }
                    Unit.right()
                }
                null -> StatusGateError.DeprecatedNotAllowed.right()
            }
        }
        is ContractStatus.DRAFT -> StatusGateError.DraftNotAllowed.left()
        is ContractStatus.ARCHIVED -> StatusGateError.ArchivedBlocked.left()
    }
}
```

**규칙**:
- **ACTIVE만 기본 허용**
- **DEPRECATED 허용 + 경고** (override 필요)
- **ARCHIVED 차단** (절대 허용 안 함)
- override는 Request 옵션이 아니라 **View/RuleSet 계약에만 허용** (인간 입력 오염 방지)

**예외**: 테스트/로컬 시뮬레이션에서는 `--allow-deprecated` 플래그 허용.

---

2-3. Canonicalization 규칙을 계약으로 고정

**문제**: Hash 계산 시 JSON 직렬화 순서/포맷이 다르면 동일 데이터도 다른 해시 발생.

**해결**: Canonical JSON 프로파일을 계약에 명시.

```kotlin
sealed interface CanonicalJsonProfile {
    object RFC8785 : CanonicalJsonProfile  // RFC 8785 (JSON Canonicalization Scheme)
    data class Custom(val name: String, val spec: String) : CanonicalJsonProfile
}

data class CanonicalizationSpec(
    val canonicalJsonProfile: CanonicalJsonProfile,
    val hashAlg: String,  // "sha256", "sha512"
    val hashScope: HashScope  // payload, slice, changeset, event
)

enum class HashScope {
    PAYLOAD,    // RawData payload
    SLICE,      // Slice data
    CHANGESET,  // ChangeSet payload
    EVENT       // Event payload (v4.1)
}
```

**규칙**:
- 모든 계약(RuleSet, ViewDefinition)에 `canonicalizationSpec` 필수
- 기본값: `RFC8785` + `sha256`
- 해시 계산은 반드시 계약에 명시된 프로파일 사용
- 프로파일 변경은 **MAJOR 버전 변경** 필요 (호환성 깨짐)

**구현**:
```kotlin
object CanonicalJson {
    fun canonicalize(json: JsonElement, profile: CanonicalJsonProfile): String {
        // RFC8785 또는 커스텀 프로파일 적용
    }
    
    fun hash(data: String, alg: String): String {
        // sha256/sha512
    }
}
```

---

2-4. EntityKey/Version 규칙을 계약으로 고정

**문제**: `entityKey` 포맷이 코드마다 다르면 조회/조인 실패.

**해결**: EntityKey 포맷을 계약으로 고정.

```kotlin
data class EntityKeySpec(
    val format: String,  // "ENTITYTYPE#tenantId#entityId"
    val separator: String = "#",
    val versionType: VersionType = VersionType.LONG_MONOTONIC,
    val versionPadWidth: Int = 10  // zero-padding 자릿수
)

enum class VersionType {
    LONG_MONOTONIC  // Long, 단조 증가, 동일 (entityKey, version)은 불변
}
```

**규칙**:
- `entityKey` 포맷: `ENTITYTYPE#tenantId#entityId` (고정)
- `version`은 반드시 `Long`, 단조 증가
- 동일 `(entityKey, version)`은 불변 (immutable)
- zeroPad 자릿수도 SSOT로 고정 (예: 10/12/16)

**예시**:
- Product: `PRODUCT#tenant1#product123`
- Brand: `BRAND#tenant1#BR001`
- Category: `CATEGORY#tenant1#CAT001`

---

2-5. SliceKey 규칙을 계약으로 고정

**문제**: Slice 저장키가 런타임에서 임의로 생성되면 조회/마이그레이션 불가.

**해결**: SliceKeySpec을 계약으로 고정.

```kotlin
data class SliceKeySpec(
    val pkPattern: String,  // "PRODUCT#{tenantId}#{productId}"
    val skPattern: String,  // "v{pad(version,12)}#{sliceType}"
    val padWidth: Int = 12,
    val separator: String = "#"
)
```

**규칙**:
- RuleSet 계약에 `sliceKeySpec` 필수
- 패턴은 템플릿 문자열 (예: `{tenantId}`, `{version}`, `{sliceType}`)
- 런타임은 계약에 명시된 패턴만 사용
- 패턴 변경은 **MAJOR 버전 변경** 필요

**예시**:
```yaml
sliceKeySpec:
  pkPattern: "PRODUCT#{tenantId}#{productId}"
  skPattern: "v{pad(version,12)}#{sliceType}"
  padWidth: 12
```

---

2-6. ChangeSet 계약에 "ImpactMap"을 1급 시민으로 포함

**문제**: ChangeSet의 `changedPaths`/`impactedSlices`만으로는 "왜 이 Slice가 재생성되는지" 불명확.

**해결**: ImpactMap을 ChangeSet 계약에 명시.

```kotlin
enum class ImpactReason {
    VALIDATION,      // 검증 규칙 변경
    FIELD_CHANGE,    // 필드 변경
    JOIN_DEP,        // JOIN 의존성 변경
    POLICY_CHANGE    // Policy 변경
}

data class ImpactMap(
    val sliceType: SliceType,
    val reason: ImpactReason,
    val paths: List<String>  // RFC-6901 JSON Pointer
)

data class ChangeSetContract(
    // ... 기존 필드
    val impactMap: Map<SliceType, ImpactMap>  // 필수
)
```

**규칙**:
- ChangeSet 생성 시 ImpactMap 계산 필수
- ImpactMap은 RuleSet의 `impact` 섹션과 일치해야 함
- ImpactMap 누락 시 ChangeSet 생성 실패 (fail-closed)

**예시**:
```yaml
impactMap:
  CORE:
    reason: FIELD_CHANGE
    paths: ["/title", "/brand", "/price"]
  DISCOVERY:
    reason: FIELD_CHANGE
    paths: ["/title", "/brand", "/tags"]
  POLICY:
    reason: POLICY_CHANGE
    paths: ["/salePolicy"]
```

---

2-7. RuleSet에 "JoinSpec(가벼운 조인)"을 계약으로 포함

**문제**: JOIN이 런타임에서 임의 구현되면 결정성/테스트 불가.

**해결**: JoinSpec을 RuleSet 계약에 명시.

```kotlin
enum class JoinType {
    LOOKUP,    // 단순 조회 (1:1)
    ARRAY,     // 배열 조회 (1:N, 제한적)
    NESTED     // 중첩 조회 (제한적, 깊이 1까지만)
}

data class JoinSpec(
    val name: String,
    val type: JoinType,
    val from: String,  // JSON Pointer (소스 필드)
    val target: JoinTarget,
    val required: Boolean,  // 필수 여부
    val fields: List<FieldMapping>  // 필드 매핑
)

data class JoinTarget(
    val entityType: EntityType,
    val keyPattern: String  // "BRAND#{tenantId}#{brandCode}"
)

data class FieldMapping(
    val fromTarget: String,  // JSON Pointer (타겟 필드)
    val to: String           // JSON Pointer (결과 필드)
)
```

**규칙**:
- JOIN은 Slice 생성 단계에서만 허용 (View에서는 재계산 안 함)
- JOIN 범위는 제한적 (라이트 조인)
- JOIN 실패 시 `required=true`면 실패, `required=false`면 null/빈값

**예시**:
```yaml
joins:
  - name: brand_join
    type: LOOKUP
    from: "/brandCode"
    target:
      entityType: BRAND
      keyPattern: "BRAND#{tenantId}#{brandCode}"
    required: true
    fields:
      - fromTarget: "/name"
        to: "/enriched/brandName"
      - fromTarget: "/logoUrl"
        to: "/enriched/brandLogo"
```

---

2-8. ViewDefinition에 "MissingPolicy + PartialPolicy + FallbackPolicy" 명시

**문제**: Slice 누락/부분적 조회 시 동작이 불명확하면 운영 오류 발생.

**해결**: Policy를 ViewDefinition 계약에 명시.

```kotlin
enum class MissingPolicy {
    FAIL_CLOSED,     // 필수 Slice 누락 시 실패
    PARTIAL_ALLOWED  // 부분적 조회 허용
}

data class PartialPolicy(
    val allowed: Boolean,
    val optionalOnly: Boolean,  // optional Slice만 누락 허용
    val responseMeta: ResponseMeta
)

data class ResponseMeta(
    val includeMissingSlices: Boolean,  // 응답에 누락 Slice 목록 포함
    val includeUsedContracts: Boolean   // 사용한 계약 버전 포함
)

enum class FallbackPolicy {
    NONE,           // Fallback 없음 (실패)
    DEFAULT_VALUE,  // 기본값 사용
    SOURCE          // 소스에서 직접 조회 (제한적)
}
```

**규칙**:
- ViewDefinition에 `missingPolicy`, `partialPolicy`, `fallbackPolicy` 필수
- `FAIL_CLOSED`가 기본값
- Fallback은 제한적 (소스 직접 조회는 성능 이슈)

**예시**:
```yaml
missingPolicy: FAIL_CLOSED
partialPolicy:
  allowed: true
  optionalOnly: true
  responseMeta:
    includeMissingSlices: true
    includeUsedContracts: true
fallbackPolicy: NONE
```

---

2-9. Tombstone 계약 고정

**문제**: 삭제/비노출의 의미가 Slice마다 다르면 재앙.

**해결**: Tombstone을 Slice 공통 필드로 고정.

```kotlin
data class Tombstone(
    val isDeleted: Boolean,
    val deletedAtVersion: Long?,
    val deleteReason: DeleteReason?
)

enum class DeleteReason {
    USER_DELETE,      // 사용자 삭제
    POLICY_HIDE,       // 정책상 숨김
    VALIDATION_FAIL,  // 검증 실패
    ARCHIVED          // 아카이브
}
```

**규칙**:
- 모든 Slice 타입에 `tombstone` 필드 필수
- `isDeleted=true`면 해당 Slice는 조회에서 제외 (View에서 필터링)
- `deletedAtVersion`은 삭제된 버전 기록
- Tombstone은 불변 (한 번 삭제되면 복구 불가, 새 버전으로 재생성)

**예시**:
```json
{
  "tombstone": {
    "isDeleted": true,
    "deletedAtVersion": 5,
    "deleteReason": "USER_DELETE"
  }
}
```

---

2-10. Event Contract(v4.1)에서 doc_id/idempotency 스키마 고정

**문제**: Sink(OpenSearch)에서 doc_id가 일관되지 않으면 멱등성 깨짐.

**해결**: DocIdSpec을 Event 계약에 명시.

```kotlin
enum class DocIdScope {
    VIEW,   // View 단위 (1 doc = 1 view)
    SLICE   // Slice 단위 (1 doc = 1 slice)
}

data class DocIdSpec(
    val scope: DocIdScope,
    val pattern: String  // "{entityKey}#{version}" 또는 "{entityKey}#{sliceType}#{version}"
)
```

**규칙**:
- Event 계약에 `docIdSpec` 필수
- doc_id는 Sink의 SSOT (멱등성 보장)
- doc_id 패턴 변경은 **MAJOR 버전 변경** 필요

**예시**:
```yaml
docIdSpec:
  scope: VIEW
  pattern: "{entityKey}#{version}"
```

---

2-11. Registry에 "Compatibility Test Artifact" 저장

**문제**: MAJOR/MINOR/PATCH 규칙만 있으면 실무에서 부족 (실제 호환성 검증 불가).

**해결**: Registry에 호환성 테스트 아티팩트 저장.

```kotlin
data class CompatibilityMatrix(
    val fromVersion: SemVer,
    val toVersion: SemVer,
    val compatibility: CompatibilityLevel,
    val breakingChanges: List<BreakingChange>
)

enum class CompatibilityLevel {
    COMPATIBLE,      // 호환됨
    INCOMPATIBLE,    // 호환 안 됨
    MANUAL_REVIEW    // 수동 검토 필요
}

data class BreakingChange(
    val type: BreakingChangeType,
    val description: String,
    val path: String?  // JSON Pointer
)

enum class BreakingChangeType {
    FIELD_REMOVED,
    FIELD_TYPE_CHANGED,
    REQUIRED_FIELD_ADDED,
    ENUM_VALUE_REMOVED
}

data class GoldenExample(
    val input: JsonElement,
    val expectedOutput: JsonElement,
    val expectedHash: String,
    val description: String
)
```

**규칙**:
- Registry에 `compatMatrix` 저장 필수
- `goldenExamples`는 최소 2개 이상 (정상 케이스 + 엣지 케이스)
- 호환성 검증은 PR 단계에서 자동 실행

**예시**:
```yaml
compatMatrix:
  - fromVersion: "1.2.0"
    toVersion: "1.3.0"
    compatibility: COMPATIBLE
    breakingChanges: []
goldenExamples:
  - input: { "title": "Test", "price": 1000 }
    expectedOutput: { "title": "Test", "price": 1000, "currency": "KRW" }
    expectedHash: "sha256:abc123..."
    description: "기본 케이스"
```

---

2-12. ReplayRequestContract를 운영 입력 SSOT로 고정

**문제**: Replay/Backfill 요청이 인간 텍스트 입력이면 DX 박살남.

**해결**: ReplayRequestContract를 계약으로 고정.

```kotlin
data class ReplayRequestContract(
    val replayId: String,  // UUID
    val reason: String,
    val tenantId: String,
    val scope: ReplayScope,
    val ruleSetRef: ContractRef,
    val verifyMode: VerifyMode,
    val cutlineVersion: Long
)

data class ReplayScope(
    val entityKeys: List<String>?,      // OR prefix OR range (단일 형태만)
    val versionRange: VersionRange,
    val sliceTypes: List<SliceType>?   // allowlist
)

data class VersionRange(
    val from: Long,
    val to: Long
)

enum class VerifyMode {
    STRICT,      // FULL vs INCREMENTAL 전수 비교
    SAMPLING,    // n% 샘플 + slice_hash 비교
    HASH_ONLY    // hash 동일성만 확인
}
```

**규칙**:
- Replay 요청은 반드시 `ReplayRequestContract` 형태로만 허용
- 계약 미준수 시 Validator 단계에서 즉시 차단
- `replayId`는 UUID (중복 실행 추적용)

**예시**:
```yaml
replayId: "550e8400-e29b-41d4-a716-446655440000"
reason: "Sink 인덱스 손상 복구"
tenantId: "tenant1"
scope:
  entityKeys: ["product#P1", "product#P2"]
  versionRange:
    from: 40
    to: 42
  sliceTypes: [CORE, DISCOVERY]
ruleSetRef:
  id: "ruleset.product.v4"
  version: "1.3.0"
verifyMode: STRICT
cutlineVersion: 42
```

---

3. DX 끝판: 개발자 경험을 "계약 중심"으로 설계

3-1. DX 목표 6개

1. **계약 작성하면 자동으로 타입/SDK 생성**
   - RuleSet/ViewDefinition 작성 → Kotlin 타입/SDK 자동 생성
   - JSON Schema 타입도 자동 생성

2. **계약 변경하면 compatibility gate가 PR에서 깨짐**
   - PR 단계에서 호환성 검증 자동 실행
   - Breaking change 감지 시 PR 차단

3. **로컬에서 end-to-end를 한 커맨드로 재현**
   - `ivm-lite simulate` 한 커맨드로 RawData → ChangeSet → Slices → View 재현

4. **slice/view 결과가 해시로 고정되어 diff 가능**
   - 동일 입력 → 동일 해시 보장
   - 해시 비교로 변경 감지

5. **replay/backfill이 계약 파일로만 실행**
   - `ivm-lite replay --contract replay-request.yaml` 형태로만 실행

6. **"무슨 계약이 실제로 쓰였는지"가 항상 추적 가능**
   - 모든 요청/응답에 사용한 계약 버전/해시 포함

---

3-2. 반드시 제공할 DX 툴링 (라이브러리 내 포함)

#### 3-2-1. `ivm-lite validate-contracts`

**용도**: 계약 파일 검증

**사용법**:
```bash
ivm-lite validate-contracts \
  --schema schema.product.yaml \
  --ruleset ruleset.product.v4.yaml \
  --view view.product.pdp.yaml \
  --replay replay-request.yaml
```

**검증 항목**:
- JSON Schema 유효성
- 계약 참조 무결성 (schemaRef, ruleSetRef 등)
- 호환성 매트릭스 검증
- Golden example 실행

**출력**:
- 검증 통과/실패
- 실패 시 상세 에러 메시지
- 호환성 리포트

---

#### 3-2-2. `ivm-lite codegen`

**용도**: 계약에서 Kotlin SDK + JSON Schema 타입 생성

**사용법**:
```bash
ivm-lite codegen \
  --ruleset ruleset.product.v4.yaml \
  --view view.product.pdp.yaml \
  --output-dir ./generated
```

**생성물**:
- Kotlin 데이터 클래스 (Slice 타입, View 타입)
- JSON Schema 파일
- SDK 인터페이스

---

#### 3-2-3. `ivm-lite simulate`

**용도**: 로컬에서 RawData → ChangeSet → Slices → View 시뮬레이션

**사용법**:
```bash
ivm-lite simulate \
  --raw raw-product.json \
  --ruleset ruleset.product.v4.yaml \
  --view view.product.pdp.yaml \
  --output-dir ./output
```

**출력**:
- ChangeSet (JSON)
- Slices (JSON, 타입별)
- View (JSON)
- 해시 리포트

---

#### 3-2-4. `ivm-lite diff`

**용도**: slice_hash/view_hash 비교

**사용법**:
```bash
ivm-lite diff \
  --before slice-v1.json \
  --after slice-v2.json \
  --ruleset ruleset.product.v4.yaml
```

**출력**:
- 해시 비교 결과
- 변경된 필드 목록
- 호환성 분석

---

#### 3-2-5. `ivm-lite replay`

**용도**: ReplayRequestContract 기반 실행

**사용법**:
```bash
ivm-lite replay \
  --contract replay-request.yaml \
  --registry-url http://localhost:10000
```

**실행 흐름**:
1. ReplayRequestContract 검증
2. 계약 로드 (RuleSet, ViewDefinition)
3. RawData 로드 (versionRange)
4. Slicing 실행 (FULL/INCREMENTAL)
5. 해시 검증 (verifyMode)
6. 결과 리포트

---

4. 최종 계약 스키마 (핵심만, 실무용)

4-1. RuleSetContract v4 (샘플)

```yaml
id: ruleset.product.v4
version: 1.3.0
status: ACTIVE

canonicalizationSpec:
  canonicalJsonProfile: RFC8785
  hashAlg: sha256
  hashScope: SLICE

entity:
  type: PRODUCT
  keySpec:
    format: "ENTITYTYPE#tenantId#entityId"
    separator: "#"
    versionType: LONG_MONOTONIC
    versionPadWidth: 12

sliceKeySpec:
  pkPattern: "PRODUCT#{tenantId}#{productId}"
  skPattern: "v{pad(version,12)}#{sliceType}"
  padWidth: 12
  separator: "#"

inputs:
  schemaRef:
    id: schema.product
    version: 2.1.0

impact:
  impactMap:
    CORE:
      paths: ["/title", "/brand", "/price"]
      reason: FIELD_CHANGE
    DISCOVERY:
      paths: ["/title", "/brand", "/tags"]
      reason: FIELD_CHANGE
    POLICY:
      paths: ["/salePolicy", "/restrictions"]
      reason: FIELD_CHANGE

joins:
  - name: brand_join
    type: LOOKUP
    from: "/brandCode"
    target:
      entityType: BRAND
      keyPattern: "BRAND#{tenantId}#{brandCode}"
    required: true
    fields:
      - fromTarget: "/name"
        to: "/enriched/brandName"
      - fromTarget: "/logoUrl"
        to: "/enriched/brandLogo"

slices:
  - type: CORE
    outputSchemaRef:
      id: slice.product.core
      version: 1.0.0
    build:
      map:
        title: "$.title"
        brandCode: "$.brandCode"
        price: "$.price"
  - type: DISCOVERY
    outputSchemaRef:
      id: slice.product.discovery
      version: 1.0.0
    build:
      tokenize:
        fields: ["$.title", "$.tags[*]"]
  - type: POLICY
    outputSchemaRef:
      id: slice.product.policy
      version: 1.0.0
    build:
      validate:
        rules: ["no_alcohol_to_us", "age_restriction"]

compatMatrix:
  - fromVersion: "1.2.0"
    toVersion: "1.3.0"
    compatibility: COMPATIBLE
    breakingChanges: []

goldenExamples:
  - input:
      title: "Test Product"
      brandCode: "BR001"
      price: 10000
    expectedOutput:
      core:
        title: "Test Product"
        brandCode: "BR001"
        price: 10000
      discovery:
        tokens: ["Test", "Product", "BR001"]
    expectedHash: "sha256:abc123..."
    description: "기본 케이스"
```

---

4-2. ViewDefinitionContract v4 (샘플)

```yaml
id: view.product.pdp.v4
version: 1.0.0
status: ACTIVE

requiredSlices:
  - CORE
  - VARIANT
  - POLICY

optionalSlices:
  - CONTENT_INDEX
  - DISCOVERY

missingPolicy: FAIL_CLOSED

partialPolicy:
  allowed: true
  optionalOnly: true
  responseMeta:
    includeMissingSlices: true
    includeUsedContracts: true

fallbackPolicy: NONE

join:
  strategy: VIRTUAL
  order:
    - CORE
    - VARIANT
    - POLICY
    - CONTENT_INDEX
    - DISCOVERY

projection:
  fields:
    - from: "CORE.title"
      to: "title"
    - from: "CORE.price"
      to: "price"
    - from: "VARIANT.skus"
      to: "skus"

ruleSetRef:
  id: ruleset.product.v4
  version: 1.3.0
```

---

5. 최종 "DX 끝판" 레포 구조

```
com/oliveyoung/ivmlite/
  shared/              # 공통 인프라/타입
    domain/
      determinism/
        CanonicalJson.kt
        Hashing.kt
      errors/
        DomainError.kt
      types/
        CoreTypes.kt
    ports/
      SingleFlightPort.kt
    adapters/
      InProcessSingleFlight.kt

  package/             # 도메인들 그룹화
    rawdata/
      domain/
        RawDataRecord.kt
      ports/
        RawDataRepositoryPort.kt
      adapters/
        InMemoryRawDataRepository.kt

    changeset/
      domain/
        ChangeSet.kt
        ChangeSetBuilder.kt

    contracts/
      domain/
        Contracts.kt
        ContractStatus.kt
      ports/
        ContractRegistryPort.kt
      adapters/
        LocalYamlContractRegistryAdapter.kt

    slices/
      domain/
        SliceRecord.kt
        JoinSpec.kt
        InvertedIndexEntry.kt
        InvertedIndexKeys.kt
      ports/
        SliceRepositoryPort.kt
        InvertedIndexRepositoryPort.kt
      adapters/
        InMemorySliceRepository.kt
        InMemoryInvertedIndexRepository.kt

  tooling/             # DX 도구 (개발자 경험 향상)
    application/
      ValidateContracts.kt  # 계약 파일 검증
      # 향후 추가:
      # - CodeGenerator.kt (계약 → Kotlin SDK 생성)
      # - Simulator.kt (로컬 시뮬레이션)
      # - DiffCalculator.kt (해시 비교)
      # - ReplayExecutor.kt (ReplayRequestContract 실행)

  apps/                # 애플리케이션 진입점
    runtimeapi/        # 런타임 API (UseCase 레이어)
      InsertRawDataUseCase.kt
      QueryViewUseCase.kt
      SlicingUseCase.kt
    opscli/            # 운영 CLI 진입점
      OpsCliApp.kt
```

**설계 원칙**:
- Domain-sliced + In-domain Hexagonal
- 도메인들은 `package/` 디렉토리 아래로 그룹화하여 구조 명확화
- Kotlin, single-module (멀티모듈은 나중에)
- 각 도메인은 독립적으로 테스트 가능
- **Tooling은 별도 모듈 (런타임과 분리)**: 개발/테스트 단계에서만 사용되는 DX 도구들

---

6. 추가로 "반드시" 들어가야 할 라이브러리 기능 9개

6-1. Contract Loader 캐시 + hash pinning

**목적**: 어떤 계약을 썼는지 request마다 추적 가능

**구현**:
```kotlin
interface ContractLoaderPort {
    suspend fun load(ref: ContractRef): Either<LoadError, LoadedContract>
    suspend fun loadWithHash(ref: ContractRef): Either<LoadError, LoadedContractWithHash>
}

data class LoadedContractWithHash(
    val contract: LoadedContract,
    val contentHash: String,  // 계약 내용 해시
    val loadedAt: Instant
)

// 캐시는 LRU, TTL 설정 가능
class CachedContractLoader(
    private val delegate: ContractLoaderPort,
    private val cache: Cache<ContractRef, LoadedContractWithHash>
) : ContractLoaderPort
```

**사용**:
- 모든 요청에 사용한 계약 버전/해시 로깅
- 계약 변경 추적

---

6-2. Canonical JSON + hash utility SSOT

**목적**: 모든 hash는 동일 구현 사용

**구현**:
```kotlin
object CanonicalJson {
    fun canonicalize(json: JsonElement, profile: CanonicalJsonProfile): String {
        // RFC8785 또는 커스텀 프로파일 적용
    }
    
    fun hash(data: String, alg: String): String {
        // sha256/sha512
    }
    
    fun hashJson(json: JsonElement, spec: CanonicalizationSpec): String {
        val canonical = canonicalize(json, spec.canonicalJsonProfile)
        return hash(canonical, spec.hashAlg)
    }
}
```

**규칙**:
- 모든 해시 계산은 이 유틸리티 사용
- 직접 해시 계산 금지

---

6-3. Deterministic ordering library

**목적**: slice list, join order, map key 순서 고정

**구현**:
```kotlin
object DeterministicOrder {
    fun <T> sortSlices(slices: List<Slice>): List<Slice> {
        // SliceType 순서 고정 (CORE, VARIANT, ...)
    }
    
    fun <K, V> sortMap(map: Map<K, V>): List<Pair<K, V>> {
        // 키 알파벳 순서
    }
    
    fun sortJsonObject(obj: JsonObject): JsonObject {
        // 필드 알파벳 순서
    }
}
```

**규칙**:
- 모든 리스트/맵 정렬은 이 유틸리티 사용
- 결정성 보장

---

6-4. SingleFlight (동일 entityKey/version 동시 실행 dedupe)

**목적**: 동일 요청 중복 실행 방지

**구현**:
```kotlin
class SingleFlight<T> {
    private val inflight = ConcurrentHashMap<String, CompletableDeferred<T>>()
    
    suspend fun execute(key: String, block: suspend () -> T): T {
        val deferred = CompletableDeferred<T>()
        val existing = inflight.putIfAbsent(key, deferred)
        
        return if (existing != null) {
            existing.await()
        } else {
            try {
                val result = block()
                deferred.complete(result)
                result
            } catch (e: Throwable) {
                deferred.completeExceptionally(e)
                throw e
            } finally {
                inflight.remove(key)
            }
        }
    }
}
```

**사용**:
- 동일 `(entityKey, version, ruleSet)` 조합은 single-flight
- 중복 실행 방지

---

6-5. Conditional Put wrapper (멱등성 표준)

**목적**: "같으면 OK, 다르면 InvariantViolation"을 공통화

**구현**:
```kotlin
sealed interface ConditionalPutResult {
    object Inserted : ConditionalPutResult
    object AlreadyExistsSame : ConditionalPutResult
    data class Conflict(val existingHash: String, val attemptedHash: String) : ConditionalPutResult
}

interface ConditionalPutPort {
    suspend fun putIfAbsentOrSame(
        key: Key,
        value: Value,
        hash: String
    ): Either<InvariantViolation, ConditionalPutResult>
}
```

**규칙**:
- Hash Registry, Slice 저장 등에서 사용
- 멱등성 보장

---

6-6. Golden test runner (계약에 포함된 예제 자동 실행)

**목적**: 계약에 포함된 예제 자동 실행

**구현**:
```kotlin
class GoldenTestRunner {
    suspend fun run(
        contract: RuleSetContract,
        examples: List<GoldenExample>
    ): Either<TestFailure, TestResult> {
        examples.forEach { example ->
            val result = simulate(contract, example.input)
            val hash = hashJson(result, contract.canonicalizationSpec)
            
            if (hash != example.expectedHash) {
                return TestFailure.HashMismatch(
                    expected = example.expectedHash,
                    actual = hash
                ).left()
            }
        }
        return TestResult.Success.right()
    }
}
```

**사용**:
- `ivm-lite validate-contracts`에서 자동 실행
- CI/CD에서 자동 실행

---

6-7. Property test kit (FULL==INCREMENTAL)

**목적**: FULL slicing과 INCREMENTAL slicing 결과 일치 검증

**구현**:
```kotlin
class PropertyTestKit {
    suspend fun verifyFullEqualsIncremental(
        rawData: List<RawData>,
        ruleSet: RuleSetContract
    ): Either<PropertyViolation, Unit> {
        // FULL slicing
        val fullResult = slicingEngine.fullSlice(rawData, ruleSet)
        
        // INCREMENTAL slicing
        val incrementalResult = rawData.fold(emptyList<Slice>()) { acc, data ->
            val changeSet = changeSetBuilder.build(acc.lastOrNull(), data)
            val slices = slicingEngine.incrementalSlice(changeSet, ruleSet)
            acc + slices
        }
        
        // 비교
        if (fullResult.hash != incrementalResult.hash) {
            return PropertyViolation.FullIncrementalMismatch.left()
        }
        
        return Unit.right()
    }
}
```

**사용**:
- 계약 변경 시 자동 실행
- 결정성 보장

---

6-8. ReplayRequest validator (운영 입력 계약)

**목적**: ReplayRequestContract 검증

**구현**:
```kotlin
class ReplayRequestValidator {
    fun validate(request: ReplayRequestContract): Either<ValidationError, Unit> {
        // ruleSetRef ACTIVE 상태인가
        // version 연속성 유지되는가
        // scope가 계약에 맞게 단일 형태인가
        // verifyMode가 replay 유형에 적합한가
        // cutlineVersion이 고정되었는가
    }
}
```

**규칙**:
- 검증 실패 시 실행 차단
- 로그 기록
- 운영자 승인 필요

---

6-9. Explain output (DX 핵심)

**목적**: queryView 결과에 "사용한 계약 버전/해시/누락 slice" 메타 포함

**구현**:
```kotlin
data class ViewResponse<T>(
    val data: T,
    val meta: ViewMeta?
)

data class ViewMeta(
    val usedContracts: List<ContractRef>,
    val contractHashes: Map<ContractRef, String>,
    val missingSlices: List<SliceType>,
    val partial: Boolean
)

interface ViewPort {
    suspend fun queryView(
        request: ViewRequest,
        includeMeta: Boolean = false
    ): Either<ViewError, ViewResponse<ViewData>>
}
```

**사용**:
- 디버깅 용이
- 계약 변경 추적
- 운영 모니터링

---

7. 마이그레이션 계획

7-1. Phase 1: 계약 스키마 확장 (v4.0)

- [ ] ContractRef 표준화
- [ ] ContractStatusGate 구현
- [ ] CanonicalizationSpec 추가
- [ ] EntityKeySpec/SliceKeySpec 추가
- [ ] ImpactMap 추가
- [ ] JoinSpec 추가
- [ ] MissingPolicy/PartialPolicy 추가
- [ ] Tombstone 추가

**기간**: 2주

---

7-2. Phase 2: DX 툴링 구현 (v4.0)

- [ ] `ivm-lite validate-contracts`
- [ ] `ivm-lite codegen`
- [ ] `ivm-lite simulate`
- [ ] `ivm-lite diff`
- [ ] `ivm-lite replay`

**기간**: 3주

---

7-3. Phase 3: 라이브러리 기능 구현 (v4.0)

- [ ] Contract Loader 캐시
- [ ] Canonical JSON + hash utility
- [ ] Deterministic ordering
- [ ] SingleFlight
- [ ] Conditional Put wrapper
- [ ] Golden test runner
- [ ] Property test kit
- [ ] ReplayRequest validator
- [ ] Explain output

**기간**: 2주

---

7-4. Phase 4: Event Contract (v4.1)

- [ ] DocIdSpec 추가
- [ ] Event 계약 스키마 확장
- [ ] Sink idempotency 보장

**기간**: 1주

---

8. Non-Negotiable Invariants

8-1. Contract is Law (확장)

계약은 법이며, 런타임은 계약을 기계적으로 집행한다.
계약에 명시되지 않은 동작은 금지된다.

8-2. Fail-Closed by Default

계약 검증 실패, 상태 위반, 호환성 위반은 기본 오류다.
Override는 계약에만 허용 (인간 입력 오염 방지).

8-3. Determinism Guaranteed

동일 입력 + 동일 계약 = 동일 결과 (해시 포함).
FULL slicing == INCREMENTAL slicing (속성 테스트로 보장).

8-4. Idempotency Guaranteed

동일 key/version 재실행은 부작용 없이 동일 결과 반환.
Hash 기반 멱등성 보장.

8-5. DX First

개발자 경험은 "계약 중심"으로 설계된다.
계약 작성 → 자동 생성 → 로컬 시뮬레이션 → 배포까지 원클릭.

---

9. Final Judgment

RFC-V4-003은 다음을 보장한다:

계약에서 빠지기 쉬운 구멍을 정의로 봉인
계약 작성 → 타입/SDK 자동 생성 → 로컬 시뮬레이션 → 배포까지 원클릭
계약 변경 시 호환성 검증이 PR 단계에서 자동 차단
운영 입력(Replay/Backfill)도 계약으로만 허용
"무슨 계약이 실제로 쓰였는지"가 항상 추적 가능

이 RFC까지 포함하면 v4/v4.1 스택은:

**Contract → Codegen → Simulate → Deploy → Replay**

전 과정을 사람이 실수해도 망가지지 않게 닫는다.

---

## 부록: 계약 파일 예시

### A. RuleSetContract (전체)

```yaml
id: ruleset.product.v4
version: 1.3.0
status: ACTIVE

canonicalizationSpec:
  canonicalJsonProfile: RFC8785
  hashAlg: sha256
  hashScope: SLICE

entity:
  type: PRODUCT
  keySpec:
    format: "ENTITYTYPE#tenantId#entityId"
    separator: "#"
    versionType: LONG_MONOTONIC
    versionPadWidth: 12

sliceKeySpec:
  pkPattern: "PRODUCT#{tenantId}#{productId}"
  skPattern: "v{pad(version,12)}#{sliceType}"
  padWidth: 12
  separator: "#"

inputs:
  schemaRef:
    id: schema.product
    version: 2.1.0

impact:
  impactMap:
    CORE:
      paths: ["/title", "/brand", "/price"]
      reason: FIELD_CHANGE
    DISCOVERY:
      paths: ["/title", "/brand", "/tags"]
      reason: FIELD_CHANGE
    POLICY:
      paths: ["/salePolicy", "/restrictions"]
      reason: FIELD_CHANGE

joins:
  - name: brand_join
    type: LOOKUP
    from: "/brandCode"
    target:
      entityType: BRAND
      keyPattern: "BRAND#{tenantId}#{brandCode}"
    required: true
    fields:
      - fromTarget: "/name"
        to: "/enriched/brandName"
      - fromTarget: "/logoUrl"
        to: "/enriched/brandLogo"

slices:
  - type: CORE
    outputSchemaRef:
      id: slice.product.core
      version: 1.0.0
    build:
      map:
        title: "$.title"
        brandCode: "$.brandCode"
        price: "$.price"
  - type: DISCOVERY
    outputSchemaRef:
      id: slice.product.discovery
      version: 1.0.0
    build:
      tokenize:
        fields: ["$.title", "$.tags[*]"]
  - type: POLICY
    outputSchemaRef:
      id: slice.product.policy
      version: 1.0.0
    build:
      validate:
        rules: ["no_alcohol_to_us", "age_restriction"]

compatMatrix:
  - fromVersion: "1.2.0"
    toVersion: "1.3.0"
    compatibility: COMPATIBLE
    breakingChanges: []

goldenExamples:
  - input:
      title: "Test Product"
      brandCode: "BR001"
      price: 10000
    expectedOutput:
      core:
        title: "Test Product"
        brandCode: "BR001"
        price: 10000
      discovery:
        tokens: ["Test", "Product", "BR001"]
    expectedHash: "sha256:abc123..."
    description: "기본 케이스"
```

### B. ViewDefinitionContract (전체)

```yaml
id: view.product.pdp.v4
version: 1.0.0
status: ACTIVE

requiredSlices:
  - CORE
  - VARIANT
  - POLICY

optionalSlices:
  - CONTENT_INDEX
  - DISCOVERY

missingPolicy: FAIL_CLOSED

partialPolicy:
  allowed: true
  optionalOnly: true
  responseMeta:
    includeMissingSlices: true
    includeUsedContracts: true

fallbackPolicy: NONE

join:
  strategy: VIRTUAL
  order:
    - CORE
    - VARIANT
    - POLICY
    - CONTENT_INDEX
    - DISCOVERY

projection:
  fields:
    - from: "CORE.title"
      to: "title"
    - from: "CORE.price"
      to: "price"
    - from: "VARIANT.skus"
      to: "skus"

ruleSetRef:
  id: ruleset.product.v4
  version: 1.3.0
```

### C. ReplayRequestContract (전체)

```yaml
replayId: "550e8400-e29b-41d4-a716-446655440000"
reason: "Sink 인덱스 손상 복구"
tenantId: "tenant1"
scope:
  entityKeys: ["product#P1", "product#P2"]
  versionRange:
    from: 40
    to: 42
  sliceTypes: [CORE, DISCOVERY]
ruleSetRef:
  id: ruleset.product.v4
  version: "1.3.0"
verifyMode: STRICT
cutlineVersion: 42
```
