RFC-V4-005 — Domain-sliced Package Layout + In-domain Hexagonal Architecture

Domain-sliced Package Layout + In-domain Hexagonal Architecture

Status: Draft
Created: 2026-01-25
Scope: ivm-lite (v0 단일 모듈, 추후 멀티모듈 승격 경로 포함)
Depends on: RFC-V4-001, RFC-V4-002, RFC-V4-003, RFC-V4-004
Audience: Platform / Architecture / Developers
Non-Goals: v0에서 멀티모듈 강제, 도메인 간 직접 참조 허용, shared에 비즈니스 로직 추가
0. Executive Summary

본 RFC는 ivm-lite 라이브러리의 패키지 레이아웃과 아키텍처 구조를 정의한다.

1. 결론
1-1. 채택 아키텍처

“도메인 단위로 먼저 슬라이싱” 후 각 도메인 내부에 헥사고날(domain/application/ports/adapters) 배치 구조 채택함

v0 단일 모듈 유지하면서, v1+ 멀티모듈 승격 비용 최소화됨

핵심 성공 조건은 shared(core)의 역할/범위 고정 + 도메인 간 참조 규칙(직접 import 금지) 강제임

1-2. 적용 범위

Kotlin/Spring 기반 서버 프로젝트 기준

ivm-lite 단일 레포/단일 Gradle 모듈(v0)로 시작, 구조만 먼저 고정함

2. 문제 정의
2-1. 해결하려는 문제

v0에서 빠르게 개발하면서도 도메인 분리의 “되돌리기 어려움”을 제거해야 함

도메인 간 의존이 섞이면 증분/슬라이싱/뷰/싱크 확장 시 변경 비용 폭발함

AI/협업 개발에서 “어디에 코드를 둬야 하는가”가 애매하면 토큰/시간이 누수됨

2-2. 설계 목표

도메인 경계를 파일/패키지 레벨에서 즉시 보이게 고정

도메인 간 연결은 오직 wiring에서만 발생하도록 강제

shared는 최소 공통 코어만 유지(비즈니스 의미 로직 금지)

3. 핵심 원칙
3-1. Domain-sliced 우선

최상위는 도메인 단위 디렉터리로 슬라이싱함

각 도메인은 자체 헥사고날을 “내부에” 보유함

결과적으로 “도메인 경계”와 “레이어 경계”가 동시에 유지됨

3-2. In-domain Hexagon 고정

domain/ : 순수 의미 모델 + 불변식 + 순수 계산

application/ : 유스케이스(오케스트레이션) + 입력 검증 + 트랜잭션 경계

ports/ : 외부 의존 계약(인터페이스)

adapters/ : 인프라 구현(DB, registry, messaging 등)

3-3. shared 최소화

결정성/타입/공통 포트/공통 wiring만 허용

shared에 RawData/ChangeSet/Slicing/View 의미 로직 금지

4. 최상위 패키지 구조

**4-0. 최종 형태**

v0는 단일 모듈로 시작하되, 디렉터리 구조를 그대로 멀티모듈로 승격 가능하게 고정하는 형태가 최종임.

**핵심 원칙**:
- 도메인 단위 슬라이싱 + 도메인 내부 헥사고날 유지
- 도메인들은 `package/` 디렉토리 아래로 그룹화하여 구조 명확화
- 트리거 계층은 `apps/*`로 분리
- DX 도구는 `tooling/`으로 분리 (런타임과 독립)
- sink 플러그인은 sink/adapters/plugins/*로 관리하는 구조가 SOTA임

**4-1. v0 단일 모듈 레포 구조 (최종)**

```
ivm-lite/
  README.md
  build.gradle.kts
  settings.gradle.kts

  docs/
    rfc/
      RFC-V4-005-domain-sliced-layout.md

  src/main/kotlin/com/oliveyoung/ivmlite/
    shared/
      domain/
        determinism/
          CanonicalJson.kt
          Hashing.kt
        errors/
          DomainError.kt
        types/
          CoreTypes.kt
      ports/
        SingleFlightPort.kt
      adapters/
        InProcessSingleFlight.kt

    package/  # 도메인들 그룹화
      rawdata/
        domain/
          RawDataRecord.kt
        ports/
          RawDataRepositoryPort.kt
        adapters/
          InMemoryRawDataRepository.kt

      changeset/
        domain/
          ChangeSet.kt
          ChangeSetBuilder.kt

      contracts/
        domain/
          Contracts.kt
          ContractStatus.kt
        ports/
          ContractRegistryPort.kt
        adapters/
          LocalYamlContractRegistryAdapter.kt

      slices/
        domain/
          SliceRecord.kt
          JoinSpec.kt
          InvertedIndexEntry.kt
          InvertedIndexKeys.kt
        ports/
          SliceRepositoryPort.kt
          InvertedIndexRepositoryPort.kt
        adapters/
          InMemorySliceRepository.kt
          InMemoryInvertedIndexRepository.kt

      orchestration/  # 여러 도메인 조율(워크플로우) UseCase
        application/
          InsertRawDataUseCase.kt
          SlicingUseCase.kt
          QueryViewUseCase.kt

    tooling/  # DX 도구 (개발자 경험 향상)
      application/
        ValidateContracts.kt  # 계약 파일 검증
        # 향후 추가: CodeGenerator, Simulator, DiffCalculator, ReplayExecutor

    apps/
      runtimeapi/  # 런타임 트리거/엔트리포인트 (API/worker 등, 비즈니스 로직 최소화)

      opscli/  # 운영 CLI 진입점
        OpsCliApp.kt

  src/test/kotlin/com/oliveyoung/ivmlite/
    shared/
    package/
    tooling/
    apps/
```

**4-2. v1+ 멀티모듈 승격 구조 (동일 트리 승격)**

```
ivm-lite/
  settings.gradle.kts
  build.gradle.kts

  modules/
    shared/
    rawdata/
    changeset/
    slicing/
    view/
    sink/
    apps-runtimeapi/
    apps-sinkworker/
    apps-opscli/
    apps-sinksubscriber/  # 확장 가능 (RFC-007)

  docs/
    rfc/
```

각 모듈 내부는 동일한 헥사고날 트리 유지:

```
modules/sink/src/main/kotlin/com/company/ivmlite/sink/
  domain/
  application/
  ports/
  adapters/
    registry/
    plugins/
      opensearch/
      personalize/
```

**4-3. "subscriber 확장"을 위한 트리거 계층 추가 (열려있음)**

**EventBus subscriber를 붙이는 경우**:

```
src/main/kotlin/com/company/ivmlite/apps/
  sinksubscriber/
    SinkSubscriberMain.kt
    adapters/
      kafka/
        KafkaSubscriptionAdapter.kt
    wiring/
      SinkSubscriberWiring.kt
```

**원칙**:
- subscriber는 이벤트 수신 + taskRef 해석 + SinkOrchestrator 호출만 수행
- sink 실행 로직은 절대 apps에 복제하지 않음

**4-4. 최종 룰 (레포 구조 관점, P0, 필수)**

**4-4-1. 도메인 간 직접 참조 금지**

- `sink.adapters.plugins`가 `slicing.domain`을 직접 import 금지
- 반드시 `SliceReaderPort`/`ViewReaderPort`로만 접근
- 도메인 경계 유지 (7-1)

**4-4-2. wiring에서만 조립**

- 플러그인 등록, registry 주입은 `shared/wiring` 또는 `apps/*/wiring`에서만
- 도메인 폴더 내부에서 타 도메인 adapter를 new/주입하는 코드 금지

**4-4-3. 정책/계약은 registry로**

- SinkRule/PluginDescriptor/JoinSpec/DependencyMap은 `shared/contract-registry`(또는 그 adapter)로 고정
- Contract Registry에 저장 (RFC-003: 2-16)

4-5. v0 최소 도메인(추천)

shared/

rawdata/

changeset/ (RFC-001 핵심: 증분 업데이트)

slicing/

view/

apps/runtimeapi/

나머지는 v1 이후 단계적 추가가 자연스러운 순서임

cdc/, sink/ (v4.1)

ops/ (replay/backfill, RFC-004)

**참고**: changeset은 RFC-001에서 핵심 개념이므로 v0에서 포함 권장

5. shared 패키지 규칙
5-1. shared가 포함할 것(허용)

결정성 유틸: canonical JSON, 정렬 규칙, hashing

공통 에러 모델: DomainError 계열 (HardFailure, SoftFailure, ContractError 등)

공통 타입: TenantId, EntityKey, Version, ContractRef, Hash, Ref

공통 포트: 
  - ClockPort (시간 주입)
  - SingleFlightPort (동시성 제어)
  - ContractRegistryPort (계약 레지스트리 - 모든 도메인 공통)
  - ObservabilityPort (메트릭/로그/트레이스)
  - TenantValidatorPort (멀티테넌트 격리 검증)

공통 wiring: 도메인 조립(모든 도메인의 DI 조립 지점)

5-2. shared가 포함하면 안 되는 것(금지)

RawData/ChangeSet/Slicing/View/Sink의 의미 로직

특정 도메인의 정책/룰/계산식

“편하니까” 라는 이유의 공통화(도메인 오염 시작점)

6. 도메인별 내부 구조 예시
6-1. changeset 도메인 예시

changeset/
  domain/
    ChangeSet.kt
    ImpactMap.kt
    FanoutSource.kt  # RFC-001 보완: fanout source
  application/
    ChangeSetBuilderUseCase.kt
    ImpactMapCalculator.kt
  ports/
    RawDataReaderPort.kt
    ChangeSetRepositoryPort.kt
  adapters/
    dynamodb/
      ChangeSetRepositoryAdapter.kt

6-2. slicing 도메인 예시
slicing/
  domain/
    Slice.kt
    SliceType.kt
    SlicingEngine.kt
    Tombstone.kt
    JoinSpec.kt
    InvertedIndexKey.kt
    InvertedIndexBuilder.kt
    InvertedIndexEntry.kt  # (refEntityKey, refVersion) 기준 구조
  application/
    SlicingUseCase.kt
    SlicingMode.kt
    validators/
      SliceInvariantValidator.kt
  ports/
    SliceRepositoryPort.kt
    RawDataReaderPort.kt
    ChangeSetReaderPort.kt
    InvertedIndexRepositoryPort.kt  # Inverted Index 저장/조회
  adapters/
    dynamodb/
      SliceRepositoryAdapter.kt
      InvertedIndexRepositoryAdapter.kt


핵심 불변식

slicing.ports.RawDataReaderPort는 rawdata 도메인 구현에 직접 의존하지 않음

실제 구현 연결은 shared/wiring 또는 apps/*/wiring에서 주입함

6-3. view 도메인 예시
view/
  domain/
    ViewDefinition.kt
    ViewJoiner.kt
    MissingPolicy.kt
    PartialPolicy.kt
    FallbackPolicy.kt
    ViewMeta.kt  # Explain API용 메타데이터
  application/
    QueryViewUseCase.kt
    ExplainViewUseCase.kt  # Explain API (RFC-003)
  ports/
    SliceBatchReaderPort.kt
  adapters/
    dynamodb/
      SliceBatchReaderAdapter.kt

6-4. ops 도메인 예시 (v1+)

ops/
  domain/
    ReplayRequest.kt
    ReplayScope.kt
    VerifyMode.kt
    ReplayValidator.kt
  application/
    ReplayUseCase.kt
    BackfillUseCase.kt
  ports/
    RawDataReaderPort.kt
    SliceRepositoryPort.kt
    InvertedIndexRepositoryPort.kt
    ChangeSetReaderPort.kt
  adapters/
    dynamodb/
      ReplayStoreAdapter.kt

7. 도메인 간 의존성 규칙
7-1. 직접 참조(import) 금지

slicing.domain → rawdata.domain import 금지

view.domain → slicing.domain import 금지

도메인 간 데이터 접근/요청은 항상 ports 계약을 통해서만 함

7-2. 도메인 간 연결은 wiring에서만 허용

shared/wiring/* 또는 apps/*/wiring/*에서만 조립 허용

도메인 폴더 내부에서 타 도메인 adapter를 new/주입하는 코드 금지

7-3. 공유는 타입만

공통 타입은 shared/domain에만 존재

도메인 의미 모델을 shared로 올리는 행위는 금지

**7-4. Contract Registry는 shared 포트 (P0)**

ContractRegistryPort는 모든 도메인에서 공통 사용되므로 shared/ports에 위치

각 도메인의 adapters/registry/ContractRegistryAdapter는 shared/ports.ContractRegistryPort 구현

이를 통해 도메인 간 Contract Registry 구현 공유 및 일관성 보장

**7-5. 보안 및 Observability 포트 (P1)**

TenantValidatorPort, ObservabilityPort는 shared/ports에 위치

모든 도메인의 application layer에서 사용하여 일관된 보안 검증 및 관찰성 보장

8. Gradle 멀티모듈 승격 경로
8-1. 승격 원칙

패키지 구조를 그대로 Gradle module로 승격 가능해야 함

v0는 단일 모듈이되, 디렉터리 구조로 “미래 모듈 경계”를 이미 고정함

8-2. 권장 모듈 맵

```
:shared
:rawdata
:slicing
:view
:changeset
:cdc
:sink
:ops
:apps:runtimeapi
:apps:cdcworker
:apps:sinkworker
:apps:opscli
:apps:sinksubscriber  # 확장 가능 (RFC-007)
```

9. 레포 구성 표준(권장)
9-1. 디렉터리 표준
ivm-lite/
  docs/rfc/
    RFC-V4-005-domain-sliced-layout.md
  src/main/kotlin/com/oliveyoung/ivmlite/
    shared/              # 공통 인프라/타입
    package/             # 도메인들 그룹화
      rawdata/
      changeset/
      contracts/
      slices/
    tooling/             # DX 도구
    apps/                # 애플리케이션 진입점
  src/test/kotlin/com/oliveyoung/ivmlite/...

9-2. 네이밍 규칙

도메인 이름은 단수 소문자: rawdata, changeset, contracts, slices

레이어 이름은 고정: domain, application, ports, adapters, wiring

도메인들은 `package/` 디렉토리 아래로 그룹화하여 구조 명확화

adapter 하위는 인프라 기술명 기반: dynamodb/, registry/, kafka/ 등

10. 적용 체크리스트
10-1. 구조 준수 체크

신규 코드는 반드시 “어느 도메인” 소속인지 먼저 결정됨

의미 모델은 domain/에만 존재

유스케이스는 application/에만 존재

외부 의존 계약은 ports/에만 존재

구현체는 adapters/에만 존재

도메인 간 조립은 wiring/에만 존재

10-2. v0 최소 구현 순서(권장)

1. shared 타입/결정성/에러/포트 정의
   - ContractRef, EntityKey, Version 등 공통 타입
   - CanonicalJson, Hashing 유틸
   - DomainError 계열 에러 모델
   - ContractRegistryPort, ObservabilityPort, TenantValidatorPort

2. rawdata 저장/조회 포트 및 adapter
   - RawDataRepositoryPort 정의
   - DynamoDB RawDataAdapter 구현

3. changeset 빌더/유스케이스 (RFC-001 핵심)
   - ChangeSetBuilderUseCase
   - ImpactMapCalculator
   - ChangeSetRepositoryPort 및 Adapter

4. slicing 엔진/유스케이스 + RawDataReaderPort 계약
   - SlicingEngine (FULL/INCREMENTAL)
   - InvertedIndexBuilder (RFC-001 보완: refEntityKey/refVersion 기준)
   - SliceRepositoryPort, InvertedIndexRepositoryPort

5. view 조회 유스케이스 + SliceBatchReaderPort 계약
   - ViewJoiner, ViewProjector
   - ExplainViewUseCase (RFC-003)

6. apps/runtimeapi에서 조립 및 엔드포인트 노출
   - 모든 도메인 wiring
   - REST API 엔드포인트

11. 결정 사항 요약
11-1. 채택

Domain-sliced + In-domain Hexagon 구조를 SSOT로 고정함

shared는 최소 코어만 허용함 (타입/결정성/에러/공통 포트만)

도메인 간 직접 참조 금지, wiring에서만 조립 허용함

Contract Registry는 shared 포트로 공유 (모든 도메인 공통)

보안 및 Observability 포트는 shared에 위치하여 일관성 보장

v0 단일 모듈로 시작하되, 동일 트리를 멀티모듈로 자연스럽게 승격 가능하게 설계함

**11-2. RFC-001~004와의 일관성**

RFC-001의 Inverted Index (refEntityKey/refVersion 기준) 반영

RFC-001의 ChangeSet fanout source 반영

RFC-002의 에러 코드 체계 (HardFailure/SoftFailure) 반영

RFC-002의 Observability 요구사항 반영

RFC-003의 Explain API (ViewMeta) 반영

RFC-001의 보안/멀티테넌트 요구사항 (TenantValidatorPort) 반영
