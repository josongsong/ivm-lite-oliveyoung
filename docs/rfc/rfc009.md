RFC-V4-009 — Rule-Driven Compiler Architecture

Rule-Driven Compiler: AggregationRule 기반 자동 최적화

Status: Final
Created: 2026-01-25
Scope: v4 Compiler Layer
Depends on: RFC-V4-001, RFC-V4-002, RFC-V4-003, RFC-V4-006
Audience: Platform / Architecture / Compiler Developers / Contract Authors
Non-Goals: 런타임 탐색형 최적화, 동적 룰 생성, 휴리스틱 기반 최적화

0. Executive Summary

본 RFC는 컴파일러가 "룰드리븐(Rule-Driven)" 방식으로 중간 aggregated IR을 자동 삽입하고 재사용하도록 설계한다.

**핵심 결론**:
- 룰드리븐은 내부적으로 3단계로 구현: **RuleRegistry → RuleMatch → PlanRewrite**
- AggregationRule을 SSOT로 저장 (버전 포함)
- 컴파일 시점에 targets/inputs을 넣고 RuleMatch로 어떤 룰이 발동되는지 결정
- 발동된 룰로 PlanRewrite (중간 aggregated IR 삽입/재사용/대체)를 수행
- Depth/Join Law로 검증한 뒤 실행
- **자동 최적화가 아니라, "정해진 규칙에 따른 기계적 재작성"임**

**RFC-001~008과의 일관성**:
- RFC-001: Slice/View 개념, JoinSpec (RFC-001: 10-2)
- RFC-002: Canonicalization/Hashing 규칙 준수
- RFC-003: Contract Registry 기반 Rule 관리
- RFC-006: RefIndexSlice/EnrichmentSlice와의 연계 (중간 aggregated IR)

---

1. 배경과 문제 정의

1-1. 문제

여러 target(slice)이 동일한 join/derive를 반복 수행하면:
- 중복 계산 발생
- 저장 공간 낭비
- 일관성 문제 (동일 입력이 다른 결과)

예시:
```
L1 ProductCore
  → SearchDoc (join.brand + join.category_path)
  → RecoFeed  (join.brand + join.category_path)
```

두 target이 동일한 join을 각각 수행함.

1-2. 목표

- 중간 aggregated slice를 자동 삽입하여 재사용
- 룰 기반으로 "언제 어떤 aggregated를 만들지" 결정
- 기계적 재작성 (결정적, 멱등적)
- 개발자는 target만 선택하면 자동으로 최적화

---

2. 핵심 개념 정의

2-1. 룰드리븐 3단계

**RuleRegistry**: AggregationRule을 SSOT로 저장 (버전 포함)

**RuleMatch**: 컴파일 시점에 targets/inputs을 넣고 어떤 룰이 발동되는지 결정

**PlanRewrite**: 발동된 룰로 그래프를 재작성 (aggregated 삽입/재사용/대체)

2-2. Capability 기반 매칭

**provides**: Slice/Target가 제공하는 capability (예: `join.brand`, `derive.price_bucket`)

**requires**: Slice/Target가 필요로 하는 capability (예: `join.brand`, `derive.search_tokens`)

**매칭 원리**: AggregationRule의 `provides`가 target의 `requires`를 커버하면 룰 발동

**Capability 형식 규칙**:
- Capability는 문자열로 표현: `{type}.{name}` (예: `join.brand`, `derive.price_bucket`)
- 타입: `join`, `derive`, `norm`, `serve`
- 이름: 소문자와 언더스코어만 허용 (`[a-z_]+`)
- 검증: 계약 로드 시 `CapabilityValidator.isValid()`로 검증 (fail-closed)

**Capability와 JoinSpec의 관계**:
- Capability는 JoinSpec의 추상화된 표현 (RFC-001: 10-2, RFC-006: 5 참조)
- `join.brand` capability는 `JoinSpec(joinSources=[brand-summary@1], target={entityType: BRAND, ...}, ...)`로 구현됨
- provides/requires는 Capability 기반으로 표현하되, 실제 구현은 JoinSpec으로 매핑됨
- SliceDescriptor의 `joinSpecs` 필드는 구체적인 join 구현을 명시하며, `provides`는 이를 추상화한 capability 목록

2-3. 중간 Aggregated IR

**목적**: 여러 target이 공통으로 사용하는 join/derive 결과를 한 번만 계산

**타입**: EnrichmentSlice (RFC-006 참조)

**구성**: EnrichmentSlice는 다음 중 하나 이상의 조합:
- CoreSlice + RefIndexSlice (RFC-006: 4-3, 권장)
- CoreSlice + RawData (직접 join, 제한적, v0)
- CoreSlice + RefIndexSlice + RawData (혼합, 제한적)

**예시**: `CatalogEnrichedSlice`가 `join.brand`, `join.category_path`를 provides
  - inputs: [product-core@1, BrandRawV1, CategoryRawV2] 또는
  - inputs: [product-core@1, BrandSummarySlice@1, CategoryPathSlice@1] (RefIndexSlice 사용)

**2-4. SliceType vs SliceDescriptor 관계**

**SliceType**: 추상 타입 (enum, RFC-001, RFC-006, RFC-009 참조)
- RFC-001 (기본): CORE, VARIANT, DISCOVERY, POLICY, CONTENT_INDEX (RFC-001: 9-2)
- RFC-006 (중간 IR): REF_INDEX (RefIndexSlice), ENRICHMENT (EnrichmentSlice) (RFC-006: 2-2)
- RFC-009 (컴파일러): TARGET (Target, 최종 서빙용)
- ImpactMap, ChangeSet 등에서 사용
- SliceType은 계약에서 명시적으로 선언되어야 함 (fail-closed)

**SliceDescriptor**: 구체적인 Slice 구현 정의 (product-core, catalog-enriched 등)
- Registry에 저장되는 계약 (RFC-003: 2-16)
- SliceType을 포함하며, 추가로 tier, inputs, provides, requires 등 메타데이터 포함

**관계**: 
- 하나의 SliceDescriptor는 하나의 SliceType을 가짐
- 예: `product-core` SliceDescriptor → SliceType: `CORE`
- 예: `catalog-enriched` SliceDescriptor → SliceType: `ENRICHMENT` (RFC-006: 4-3)
- 예: `search-doc` TargetDescriptor → SliceType: `TARGET`

**2-5. Target vs Slice 관계**

**Target** (RFC-009): 최종 서빙 목적의 Slice (serve capability를 provides)
- TargetDescriptor는 SliceDescriptor의 특수한 형태
- tier: L3 (최종 서빙 레이어)
- sliceType: TARGET
- provides: `serve.*` capability (예: `serve.search_doc`, `serve.reco_feed`)
- 직접 join하지 않음 (joinSpecs: []), requires만 선언

**Slice**: 중간 산출물 또는 최종 서빙 Slice 모두 포함
- SliceDescriptor로 정의됨
- CoreSlice, RefIndexSlice, EnrichmentSlice, Target 모두 Slice의 하위 개념

**관계**:
- Target은 Slice의 특수한 형태 (Target ⊂ Slice)
- 모든 Target은 Slice이지만, 모든 Slice가 Target은 아님

**주의**: RFC-001의 "target" (Inverted Index 맥락의 target_entity_key)과는 다른 개념임
- RFC-001: Inverted Index의 참조 대상 엔티티 (target_entity_key, target_version)
- RFC-009: 최종 서빙 목적의 Slice (TargetDescriptor)

---

3. 내부 구성요소 (필수)

3-1. Registry

```kotlin
interface AggregationRuleRegistryPort {
    suspend fun getActiveRules(tenantId: String): Either<RegistryError, List<AggregationRule>>
    suspend fun getRule(ruleId: String, version: SemVer): Either<RegistryError, AggregationRule>
}

interface SliceDescriptorRegistryPort {
    suspend fun getSlice(sliceId: String, version: SemVer): Either<RegistryError, SliceDescriptor>
    suspend fun getTarget(targetId: String, version: SemVer): Either<RegistryError, TargetDescriptor>
}

interface DepthLawRegistryPort {
    suspend fun getDepthLaw(version: SemVer): Either<RegistryError, DepthLaw>
}
```

3-2. Compiler 파이프라인

```kotlin
// 1. 기본 의존 그래프 생성
class TargetGraphBuilder {
    fun build(targets: List<TargetRef>): Either<BuildError, DependencyGraph>
}

// 2. 룰 매칭
class RuleMatcher {
    fun match(
        graph: DependencyGraph,
        rules: List<AggregationRule>,
        tenantId: String,
        maxTier: Tier
    ): Either<MatchError, ActivatedRules>
}

// 3. 그래프 재작성
class PlanRewriter {
    fun rewrite(
        graph: DependencyGraph,
        activatedRules: ActivatedRules
    ): Either<RewriteError, RewrittenGraph>
}

// 4. Law 검증
class LawEnforcer {
    fun validate(
        graph: RewrittenGraph,
        depthLaw: DepthLaw
    ): Either<LawViolation, Unit>
}

// 5. Plan 해시 계산 (결정성 고정)
class PlanHasher {
    fun hash(plan: CompilePlan): String
}

// 6. 실행 순서 산출
class TopoSorter {
    fun sort(graph: RewrittenGraph): Either<CycleError, List<ExecutionStep>>
}
```

---

4. 룰 스키마 (핵심만, 내부적으로 필요한 최소)

4-1. AggregationRuleV1 (내부 SSOT)

```kotlin
data class AggregationRule(
    val ruleId: String,
    val version: SemVer,
    val priority: Int,  // 높을수록 우선
    
    val when: RuleCondition,
    val then: RuleAction,
    val constraints: RuleConstraints
)

data class RuleCondition(
    val targetsAll: List<TargetRef>?,  // 모든 target이 매칭되어야 함
    val targetsAny: List<TargetRef>?,  // 하나라도 매칭되면 됨
    val tenantSelector: TenantSelector?  // 옵션: 특정 tenant만
)

data class RuleAction(
    val materializeSlice: SliceRef,  // 중간 IR slice (예: CatalogEnrichedSlice@v2)
    val provides: List<Capability>,  // 이 aggregated가 제공하는 capability
    val replaceDirectEdges: Boolean  // 기존 direct join edge를 강제로 제거할지
)

data class RuleConstraints(
    val maxTierAllowed: Tier  // 예: L2까지만
)

// Capability는 문자열 기반 (YAML과 일관성 유지)
typealias Capability = String

// Capability 상수 (SSOT)
object Capabilities {
    // Join capabilities
    const val JOIN_BRAND = "join.brand"
    const val JOIN_CATEGORY_PATH = "join.category_path"
    const val JOIN_CATEGORY = "join.category"
    
    // Derive capabilities
    const val DERIVE_PRICE_BUCKET = "derive.price_bucket"
    const val DERIVE_AVAILABILITY_BUCKET = "derive.availability_bucket"
    const val DERIVE_SEARCH_TOKENS = "derive.search_tokens"
    const val DERIVE_RECO_FEATURES = "derive.reco_features"
    
    // Norm capabilities
    const val NORM_PRODUCT = "norm.product"
    const val NORM_BRAND = "norm.brand"
    
    // Serve capabilities
    const val SERVE_SEARCH_DOC = "serve.search_doc"
    const val SERVE_RECO_FEED = "serve.reco_feed"
}

// Capability 검증 유틸리티
object CapabilityValidator {
    fun isValid(capability: String): Boolean {
        return capability.matches(Regex("^(join|derive|norm|serve)\\.[a-z_]+$"))
    }
}
```

**핵심**: `provides[]`가 있어야 "무엇이 중복인지"를 기계적으로 판정 가능함.

---

5. RuleMatch (어떤 룰이 발동되는지)

5-1. 매칭 입력

```kotlin
data class MatchInput(
    val targets: List<TargetRef>,  // 예: [searchDoc, recoFeed]
    val requestedCapabilities: Map<TargetRef, List<Capability>>,  // 각 target이 필요로 하는 capability
    val currentMaxTier: Tier,
    val tenantId: String,
    val country: String?
)
```

5-2. 매칭 알고리즘 (기계적)

```kotlin
class RuleMatcher {
    fun match(input: MatchInput, rules: List<AggregationRule>): Either<MatchError, ActivatedRules> {
        // 1. targetsAll/Any 조건으로 후보 룰 필터링
        val candidates = rules.filter { rule ->
            when {
                rule.when.targetsAll != null -> 
                    input.targets.containsAll(rule.when.targetsAll)
                rule.when.targetsAny != null -> 
                    input.targets.any { it in rule.when.targetsAny }
                else -> true
            }
        }
        
        // 2. constraints(tier 등) 위반 후보 제거
        val validCandidates = candidates.filter { rule ->
            input.currentMaxTier <= rule.constraints.maxTierAllowed
        }
        
        // 3. priority DESC로 정렬
        val sorted = validCandidates.sortedByDescending { it.priority }
        
        // 4. 충돌(동일 provides 중복) 시 "가장 좁게 커버하는 룰" 또는 "우선순위"로 결정
        val activated = resolveConflicts(sorted, input)
        
        return ActivatedRules(activated).right()
    }
    
    private fun resolveConflicts(
        rules: List<AggregationRule>,
        input: MatchInput
    ): List<AggregationRule> {
        // tie-break 규칙:
        // 1. 우선순위 높은 것
        // 2. provides가 더 많이 커버하는 것
        // 3. targetsAll이 targetsAny보다 우선 (더 구체적)
        // 결과는 항상 결정적이어야 함
    }
}
```

**불변식**: Contract resolution must be deterministic and single-valued (RFC-003: 2-13).

---

6. PlanRewrite (중간 aggregated IR을 실제로 삽입)

6-1. 기본 그래프 (재작성 전)

```
L1 ProductCore
  → SearchDoc (join.brand + join.category_path)
  → RecoFeed  (join.brand + join.category_path)
```

6-2. 룰 적용 후 그래프 (재작성 후)

룰: `CatalogEnriched`가 `join.brand` + `join.category_path`를 provides

```
L1 ProductCore
  → CatalogEnriched (aggregated, provides join.brand, join.category_path)
      → SearchDoc (projection only)
      → RecoFeed  (projection only)
```

6-3. 재작성 규칙 (정확히 고정)

```kotlin
class PlanRewriter {
    fun rewrite(
        graph: DependencyGraph,
        activatedRules: ActivatedRules
    ): Either<RewriteError, RewrittenGraph> {
        var currentGraph = graph
        
        activatedRules.rules.forEach { rule ->
            // 1. materializeSlice 노드 생성 (없으면)
            val materializeNode = createMaterializeNode(rule.then.materializeSlice)
            
            // 2. materializeSlice.inputs를 registry에서 가져와 그래프에 연결
            val sliceDescriptor = registry.getSlice(rule.then.materializeSlice)
            val inputEdges = createInputEdges(sliceDescriptor.inputs)
            
            // 3. 각 target의 requiredCapabilities 중 룰이 provides 하는 것들을 제거
            val coveredCapabilities = rule.then.provides
            val targets = currentGraph.targets
            
            targets.forEach { target ->
                val remainingRequires = target.requires - coveredCapabilities
                target.requires = remainingRequires
            }
            
            // 4. target이 더 이상 조인이 필요 없도록 입력을 materializeSlice로 교체
            targets.forEach { target ->
                if (target.requires.isEmpty() || 
                    target.requires.all { it in coveredCapabilities }) {
                    // target의 입력을 materializeSlice로 교체
                    replaceTargetInput(target, materializeNode)
                }
            }
            
            // 5. replaceDirectEdges=true면 기존 direct join edge를 강제로 제거
            if (rule.then.replaceDirectEdges) {
                removeDirectJoinEdges(currentGraph, coveredCapabilities)
            }
            
            // 6. 동일 materialize slice가 이미 존재하면 재사용 (중복 생성 금지)
            val existingNode = currentGraph.findNode(rule.then.materializeSlice)
            if (existingNode != null) {
                reuseNode(existingNode, targets)
            } else {
                currentGraph.addNode(materializeNode)
            }
        }
        
        return RewrittenGraph(currentGraph).right()
    }
}
```

**핵심**: 이게 룰드리븐의 "기계적" 정의임.

---

7. "Capabilities"를 어떻게 산출하나 (가장 실전적인 부분)

7-1. SliceDescriptor에 provides/requires를 박아야 함

```kotlin
data class SliceDescriptor(
    val id: String,
    val version: SemVer,
    val sliceType: SliceType,  // enum: CORE, VARIANT, DISCOVERY, POLICY, CONTENT_INDEX (RFC-001), REF_INDEX, ENRICHMENT (RFC-006), TARGET (RFC-009)
    val tier: Tier,  // L1 (Core), L2 (Enrichment), L3 (Target)
    val inputs: List<InputRef>,
    val provides: List<Capability>,  // 이 slice를 만들면 어떤 capability를 제공하는가 (JoinSpec의 추상화)
    val requires: List<Capability>,  // 이 slice를 만들려면 어떤 capability가 필요한가
    val joinSpecs: List<JoinSpec>?,  // 구체적인 join 구현 (RFC-001: 10-2, RFC-006: 5 참조)
    val output: OutputSpec,
    val store: StoreSpec,
    val key: KeySpec
)

// JoinSpec과 Capability 매핑 규칙:
// - 각 JoinSpec은 하나 이상의 Capability를 provides로 매핑됨
// - 예: JoinSpec(joinSources=[brand-summary@1], target={entityType: BRAND}, provides=[join.brand])
// - provides는 JoinSpec의 추상화된 표현이며, 실제 구현은 joinSpecs에 명시됨

data class TargetDescriptor(
    val id: String,
    val version: SemVer,
    val sliceType: SliceType = SliceType.TARGET,  // 항상 TARGET
    val tier: Tier = Tier.L3,  // 항상 L3
    val inputs: List<InputRef>,
    val requires: List<Capability>,  // 이 target이 요구하는 capability
    val provides: List<Capability>,  // 이 target이 제공하는 capability (예: serve.search_doc)
    val output: OutputSpec
)

// TargetDescriptor는 SliceDescriptor의 특수한 형태
// Target ⊂ Slice (RFC-009: 2-5)
```

**예시**:
- `CatalogEnriched` provides: `join.brand`, `join.category_path`
- `SearchDoc` requires: `join.brand`, `join.category_path`, `derive.search_tokens`
- rewrite 후 `SearchDoc`의 requires는 `derive.search_tokens`만 남음

7-2. target이 요구하는 capability는 어디서 오나

**TargetDescriptor(= Serve slice descriptor)가 requires[]를 갖고 있음**

즉 "searchDoc는 brand join이 필요"가 코드가 아니라 계약임.

---

8. 검증 (Law Enforcer)

8-1. 재작성 후에 반드시 검증함 (실패-클로즈)

```kotlin
class LawEnforcer {
    fun validate(
        graph: RewrittenGraph,
        depthLaw: DepthLaw
    ): Either<LawViolation, Unit> {
        // 1. cycle 없음
        val cycles = detectCycles(graph)
        if (cycles.isNotEmpty()) {
            return LawViolation.CycleDetected(cycles).left()
        }
        
        // 2. tier 제한 준수 (L2 aggregated가 L3로 튀면 fail)
        val tierViolations = checkTierLimits(graph, depthLaw)
        if (tierViolations.isNotEmpty()) {
            return LawViolation.TierLimitExceeded(tierViolations).left()
        }
        
        // 3. join 제한 준수 (L1에서 join 발생하면 fail)
        val joinViolations = checkJoinLimits(graph, depthLaw)
        if (joinViolations.isNotEmpty()) {
            return LawViolation.JoinLimitExceeded(joinViolations).left()
        }
        
        // 4. produces outputs가 targets를 만족하는지 검증 (coverage)
        val coverageViolations = checkCoverage(graph)
        if (coverageViolations.isNotEmpty()) {
            return LawViolation.CoverageIncomplete(coverageViolations).left()
        }
        
        return Unit.right()
    }
}
```

---

9. 파일 레이아웃 (권장)

```
ivm-lite/
  registry/
    slices/
      product-core.v1.yaml
      catalog-enriched.v1.yaml
      search-doc.v1.yaml
      reco-feed.v1.yaml
    rules/
      aggregation.v1.yaml
    laws/
      depth-law.v1.yaml
```

9-1. Slice/Target Descriptor YAML

**registry/slices/product-core.v1.yaml**:
```yaml
apiVersion: ivm.registry/v1
kind: SliceDescriptor
id: product-core
version: 1
sliceType: CORE  # SliceType (RFC-001: 9-2)
tier: L1  # Tier (L1: Core, L2: Enrichment, L3: Target)
inputs:
  - kind: raw
    ref: ProductRawV3
provides:
  - norm.product
requires: []
joinSpecs: []  # CoreSlice는 join 금지 (RFC-006: 2-2)
output:
  schemaRef: ProductCoreV1
store:
  kind: dynamodb
  table: ivm_slice_product_core_v1
key:
  partition: tenantId
  sort: productKey
```

**registry/slices/catalog-enriched.v1.yaml** (중간 aggregated IR):
```yaml
apiVersion: ivm.registry/v1
kind: SliceDescriptor
id: catalog-enriched
version: 1
sliceType: ENRICHMENT  # SliceType (RFC-001: 9-2)
tier: L2  # Tier (L1: Core, L2: Enrichment, L3: Target)
inputs:
  - kind: slice
    ref: product-core@1
  # 옵션 1: RawData 직접 join (제한적, v0)
  - kind: raw
    ref: BrandRawV1
  - kind: raw
    ref: CategoryRawV2
  # 옵션 2: RefIndexSlice 사용 (권장, v1+)
  # - kind: slice
  #   ref: brand-summary@1
  # - kind: slice
  #   ref: category-path@1
provides:
  - join.brand
  - join.category_path
  - derive.price_bucket
  - derive.availability_bucket
requires:
  - norm.product
joinSpecs:
  - name: brand_join
    type: LOOKUP
    from: "/brandCode"  # JSON Pointer (소스 필드)
    target:
      entityType: BRAND
      keyPattern: "BRAND#{tenantId}#{brandCode}"  # RFC-003: 2-7
    required: true
    fields:
      - fromTarget: "/name"
        to: "/enriched/brandName"
      - fromTarget: "/logoUrl"
        to: "/enriched/brandLogo"
    joinSources: [brand-summary@1]  # SliceRef (id@version) 또는 BrandRawV1 (RFC-001: 10-2)
    maxRows: 1
    pickRule: LatestActive
    versionRule: SameVersion
    provides:
      - join.brand
    joinImpact: [CORE, DISCOVERY]  # RFC-001: 10-2
  - name: category_join
    type: LOOKUP
    from: "/categoryCode"  # JSON Pointer (소스 필드)
    target:
      entityType: CATEGORY
      keyPattern: "CATEGORY#{tenantId}#{categoryCode}"  # RFC-003: 2-7
    required: true
    fields:
      - fromTarget: "/path"
        to: "/enriched/category_path"
    joinSources: [category-path@1]  # SliceRef (id@version) 또는 CategoryRawV2 (RFC-001: 10-2)
    maxRows: 1
    pickRule: LatestActive
    versionRule: SameVersion
    provides:
      - join.category_path
    joinImpact: [CORE, DISCOVERY]
output:
  schemaRef: CatalogEnrichedV1
store:
  kind: dynamodb
  table: ivm_slice_catalog_enriched_v1
key:
  partition: tenantId
  sort: productKey
```

**참고**: 
- EnrichmentSlice는 CoreSlice + (RefIndexSlice 또는 RawData) 조합 가능 (RFC-006: 4-3)
- RefIndexSlice 사용이 권장되나, v0에서는 RawData 직접 join도 허용 (RFC-006: 8-1)
- joinSpecs는 구체적인 join 구현을 명시하며, provides는 이를 추상화한 capability 목록

**registry/slices/search-doc.v1.yaml** (최종 serve):
```yaml
apiVersion: ivm.registry/v1
kind: TargetDescriptor  # Target은 Slice의 특수한 형태 (RFC-009: 2-5)
id: search-doc
version: 1
sliceType: TARGET  # SliceType (RFC-001: 9-2)
tier: L3  # Tier (L1: Core, L2: Enrichment, L3: Target)
inputs:
  - kind: slice
    ref: product-core@1
    # 또는 catalog-enriched@1 (AggregationRule에 의해 재작성됨)
requires:
  - join.brand
  - join.category_path
  - derive.search_tokens
provides:
  - serve.search_doc
joinSpecs: []  # Target은 직접 join하지 않음, requires만 선언
output:
  schemaRef: SearchDocV1
store:
  kind: computed
```

**registry/slices/reco-feed.v1.yaml**:
```yaml
apiVersion: ivm.registry/v1
kind: TargetDescriptor  # Target은 Slice의 특수한 형태 (RFC-009: 2-5)
id: reco-feed
version: 1
sliceType: TARGET  # SliceType (RFC-001: 9-2)
tier: L3  # Tier (L1: Core, L2: Enrichment, L3: Target)
inputs:
  - kind: slice
    ref: product-core@1
    # 또는 catalog-enriched@1 (AggregationRule에 의해 재작성됨)
requires:
  - join.brand
  - join.category_path
  - derive.reco_features
provides:
  - serve.reco_feed
joinSpecs: []  # Target은 직접 join하지 않음, requires만 선언
output:
  schemaRef: RecoFeedV1
store:
  kind: computed
```

9-2. Aggregation Rule YAML

**registry/rules/aggregation.v1.yaml**:
```yaml
apiVersion: ivm.registry/v1
kind: AggregationRuleSet
version: 1

rules:
  - id: agg-catalog-enriched-for-search-and-reco
    priority: 100
    when:
      targetsAll: [search-doc@1, reco-feed@1]
    then:
      materialize:
        slice: catalog-enriched@1
      provides:
        - join.brand
        - join.category_path
        - derive.price_bucket
        - derive.availability_bucket
      rewrite:
        replaceDirectEdges: true
        rewireTargetsTo: catalog-enriched@1
    constraints:
      maxTierAllowed: L3

  - id: agg-catalog-enriched-for-search-only
    priority: 50
    when:
      targetsAll: [search-doc@1]
    then:
      materialize:
        slice: catalog-enriched@1
      provides:
        - join.brand
        - join.category_path
      rewrite:
        replaceDirectEdges: true
        rewireTargetsTo: catalog-enriched@1
    constraints:
      maxTierAllowed: L3
```

**핵심 필드 요약**:
- `when.targetsAll/Any`: 언제 발동? (TargetRef 목록)
- `then.materialize.slice`: 어떤 aggregated slice를 만들까? (SliceRef)
- `then.provides`: 이 aggregated가 커버하는 capability (Capability 목록)
- `rewrite.rewireTargetsTo`: 타깃 입력을 어디로 바꿀까? (SliceRef)
- `replaceDirectEdges`: 기존 direct join 경로 제거할까? (Boolean)

**Capability 명명 규칙**:
- Join: `join.{entity_type}` 또는 `join.{field_name}` (예: `join.brand`, `join.category_path`)
- Derive: `derive.{derived_field}` (예: `derive.price_bucket`, `derive.search_tokens`)
- Norm: `norm.{entity_type}` (예: `norm.product`, `norm.brand`)
- Serve: `serve.{target_name}` (예: `serve.search_doc`, `serve.reco_feed`)

9-3. Depth Law YAML

**registry/laws/depth-law.v1.yaml**:
```yaml
apiVersion: ivm.registry/v1
kind: DepthLaw
version: 1

tiers:
  L1:  # Core Slice (join 금지)
    joinAllowed: false
    maxJoinEdges: 0
    description: "CoreSlice만 허용, join 금지"

  L2:  # Enrichment Slice (제한적 join 허용)
    joinAllowed: true
    maxJoinEdges: 2
    description: "EnrichmentSlice 허용, 제한적 join (RefIndexSlice 또는 RawData)"

  L3:  # Target Slice (최종 서빙)
    joinAllowed: true
    maxJoinEdges: 4
    description: "Target 허용, 직접 join하지 않음 (requires만 선언)"

global:
  cycleForbidden: true
  stableTopologicalOrder: true
```

---

10. 컴파일러가 이 파일들을 어떻게 쓰나 (초간단)

```kotlin
class CompilerPipeline {
    suspend fun compile(
        targets: List<TargetRef>,
        tenantId: String
    ): Either<CompileError, CompilePlan> {
        // 1. TargetDescriptor에서 requires 읽음
        val targetDescriptors = targets.map { registry.getTarget(it) }
        val allRequires = targetDescriptors.flatMap { it.requires }
        
        // 2. AggregationRuleSet 매칭
        val rules = registry.getActiveRules(tenantId)
        val activatedRules = ruleMatcher.match(
            graph = targetGraphBuilder.build(targets),
            rules = rules,
            tenantId = tenantId,
            maxTier = Tier.L3
        )
        
        // 3. provides로 커버되는 requires 제거
        val coveredCapabilities = activatedRules.rules.flatMap { it.then.provides }
        val remainingRequires = allRequires - coveredCapabilities
        
        // 4. graph rewire (catalog-enriched를 중간에 삽입)
        val rewrittenGraph = planRewriter.rewrite(
            graph = targetGraphBuilder.build(targets),
            activatedRules = activatedRules
        )
        
        // 5. DepthLaw로 최종 검증
        val depthLaw = registry.getDepthLaw(SemVer(1, 0, 0))
        lawEnforcer.validate(rewrittenGraph, depthLaw)
        
        // 6. Plan 해시 계산 (결정성 고정)
        val plan = CompilePlan(
            graph = rewrittenGraph,
            executionSteps = topoSorter.sort(rewrittenGraph),
            planHash = planHasher.hash(rewrittenGraph)
        )
        
        return plan.right()
    }
}
```

---

11. DX 연결 (개발자는 룰파일 몰라도 됨)

11-1. 개발자 API

```kotlin
Ivm.client()
  .ingest()
  .product { ... }
  .deploy {
    compile {
      targets { 
        searchDoc()
        recoFeed() 
      }
    }
    ship.async { 
      opensearch()
      personalize() 
    }
  }
```

**내부적으로 룰이 있으면 자동으로 catalog-enriched가 들어감.**

11-2. Plan 설명 (옵션)

```kotlin
val plan = ivm.explainLastPlan(deployId)
plan.graph // ProductCore → CatalogEnriched → (SearchDoc, RecoFeed)
plan.activatedRules // [agg-catalog-enriched-for-search-and-reco]
plan.executionSteps // [1. ProductCore, 2. CatalogEnriched, 3. SearchDoc, 4. RecoFeed]
```

---

12. 구현 산출물 (코드 레벨로 딱 잘라서)

12-1. Port 인터페이스

```kotlin
interface AggregationRuleRegistryPort {
    suspend fun getActiveRules(tenantId: String): Either<RegistryError, List<AggregationRule>>
    suspend fun getRule(ruleId: String, version: SemVer): Either<RegistryError, AggregationRule>
}

interface SliceDescriptorRegistryPort {
    suspend fun getSlice(sliceId: String, version: SemVer): Either<RegistryError, SliceDescriptor>
    suspend fun getTarget(targetId: String, version: SemVer): Either<RegistryError, TargetDescriptor>
}

interface DepthLawRegistryPort {
    suspend fun getDepthLaw(version: SemVer): Either<RegistryError, DepthLaw>
}
```

12-2. Compiler 파이프라인

```kotlin
class TargetGraphBuilder {
    fun build(targets: List<TargetRef>): Either<BuildError, DependencyGraph>
}

class RuleMatcher {
    fun match(
        graph: DependencyGraph,
        rules: List<AggregationRule>,
        tenantId: String,
        maxTier: Tier
    ): Either<MatchError, ActivatedRules>
}

class PlanRewriter {
    fun rewrite(
        graph: DependencyGraph,
        activatedRules: ActivatedRules
    ): Either<RewriteError, RewrittenGraph>
}

class LawEnforcer {
    fun validate(
        graph: RewrittenGraph,
        depthLaw: DepthLaw
    ): Either<LawViolation, Unit>
}

class PlanHasher {
    fun hash(plan: CompilePlan): String
}

class TopoSorter {
    fun sort(graph: RewrittenGraph): Either<CycleError, List<ExecutionStep>>
}
```

12-3. CompilePlan

```kotlin
data class CompilePlan(
    val graph: RewrittenGraph,
    val executionSteps: List<ExecutionStep>,
    val planHash: String,  // 결정성 고정
    val activatedRules: ActivatedRules,
    val metadata: PlanMetadata
)

data class ExecutionStep(
    val stepNumber: Int,
    val sliceRef: SliceRef,
    val dependencies: List<SliceRef>,
    val capabilities: List<Capability>
)
```

---

13. 한 문장 고정

**룰드리븐 집행은 "룰 매칭 후 그래프 재작성"이다. AggregationRule이 제공(provides)하는 capability를 기준으로 targets의 요구(requires)를 커버하도록 중간 aggregated slice를 삽입/재사용하고, direct join 경로를 제거한 뒤 Law로 검증하여 결정적 CompilePlan을 생성한다.**

---

14. Non-Negotiable Invariants

14-1. Rule Matching is Deterministic

동일 입력(targets, tenant, rules)은 항상 동일 ActivatedRules를 산출해야 함.

Tie-break 규칙이 반드시 고정되어야 함 (RFC-003: 2-13).

14-2. Plan Rewrite is Idempotent

동일 그래프 + 동일 ActivatedRules는 항상 동일 RewrittenGraph를 생성해야 함.

14-3. Law Enforcement is Fail-Closed

Law 위반 시 컴파일 실패 (절대 우회 불가).

14-4. Capability Matching is Explicit

provides/requires는 계약에 명시되어야 함 (코드 추론 금지).

14-5. Capability와 JoinSpec의 일관성

- Capability는 JoinSpec의 추상화된 표현 (RFC-001: 10-2, RFC-006: 5 참조)
- SliceDescriptor의 `provides`는 `joinSpecs`에서 제공하는 capability의 집합이어야 함
- AggregationRule의 `provides`는 materializeSlice의 `provides`와 일치해야 함
- 불일치 시 계약 검증 실패 (fail-closed)

---

15. RFC-001~008과의 일관성

15-1. RFC-001: JoinSpec

- JoinSpec은 SliceDescriptor의 `joinSpecs` 필드에 포함됨 (RFC-001: 10-2)
- AggregationRule의 materializeSlice는 EnrichmentSlice (RFC-006 참조)
- Capability는 JoinSpec의 추상화된 표현이며, provides/requires는 Capability 기반으로 매칭됨
- 실제 join 구현은 joinSpecs에 명시되며, provides는 이를 추상화한 capability 목록

15-2. RFC-003: Contract Registry

- AggregationRule, SliceDescriptor, DepthLaw는 Contract Registry에 저장됨
- 버전 관리 및 호환성 검증 적용 (RFC-003: 2-11)

15-3. RFC-006: RefIndexSlice/EnrichmentSlice

- AggregationRule의 materializeSlice는 EnrichmentSlice 타입
- RefIndexSlice는 AggregationRule의 입력으로 사용 가능
- EnrichmentSlice는 CoreSlice + (RefIndexSlice 또는 RawData) 조합 가능 (RFC-006: 4-3)

15-4. Capability와 JoinSpec 통합

- Capability는 JoinSpec의 추상화된 표현 (RFC-009: 2-2)
- SliceDescriptor의 `provides`는 `joinSpecs`에서 제공하는 capability의 집합이어야 함
- AggregationRule의 `provides`는 materializeSlice의 `provides`와 일치해야 함
- 불일치 시 계약 검증 실패 (fail-closed, RFC-009: 14-5)

---

16. 마이그레이션 계획

16-1. Phase 1: Registry 확장 (v4.0)

- [ ] AggregationRuleRegistryPort 구현
- [ ] SliceDescriptorRegistryPort 확장 (provides/requires 필드 추가)
- [ ] DepthLawRegistryPort 구현
- [ ] JoinSpec과 Capability 매핑 로직 구현 (RFC-001: 10-2, RFC-006: 5, RFC-009: 2-2)
- [ ] SliceDescriptor의 joinSpecs 필드 추가 및 provides와의 일관성 검증

**기간**: 1주

16-2. Phase 2: Compiler 파이프라인 구현 (v4.0)

- [ ] TargetGraphBuilder 구현
- [ ] RuleMatcher 구현
- [ ] PlanRewriter 구현
- [ ] LawEnforcer 구현
- [ ] PlanHasher 구현
- [ ] TopoSorter 구현

**기간**: 2주

16-3. Phase 3: DX 통합 (v4.0)

- [ ] 개발자 API 통합
- [ ] Plan 설명 API 구현
- [ ] CLI 도구 통합

**기간**: 1주

---

17. Final Judgment

RFC-V4-009는 다음을 보장한다:

- 룰드리븐 컴파일러는 "룰 매칭 후 그래프 재작성"으로 구현됨
- AggregationRule이 제공하는 capability를 기준으로 자동 최적화
- 개발자는 target만 선택하면 자동으로 중간 aggregated slice 삽입
- 모든 재작성은 결정적이고 멱등적임
- Law 검증으로 안전성 보장

이 RFC까지 포함하면 v4 스택은:

**Target Selection → Rule Match → Plan Rewrite → Law Validation → Execution**

전 과정을 사람이 실수해도 망가지지 않게 닫는다.
