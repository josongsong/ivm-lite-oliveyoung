RFC-V4-004 (Final)

Replay / Backfill Operational Playbook
Deterministic Rebuild, Safe Recovery, Sink Rehydration

Status: Final → **ADR로 마이그레이션됨** ([ADR-0004](../adr/0004-replay-backfill-operations.md))
Scope: v4.1 Operations
Depends on: RFC-V4-001, RFC-V4-002, RFC-V4-003
Audience: Platform / Infra / On-call / Release Owner
Non-Goals: 자동 힐링, 실시간 롤백, Sink 단독 복구

> **참고**: 이 RFC는 ADR-0004로 마이그레이션되었습니다. 핵심 결정사항은 ADR을 참고하세요.
> 상세한 설계 내용은 이 RFC 문서를 참고하세요.

0. 목적 (Why)

v4/v4.1 아키텍처에서 Replay / Backfill은 장애 대응 수단이 아니라 정상 운영 절차다.
본 RFC는 다음을 기계적으로 보장한다.

언제 replay/backfill이 필요한지

무엇을 SSOT로 삼아 다시 계산하는지

어느 레이어에서 실행되는지

허용되는 replay와 금지되는 replay의 경계

운영 중 실수로 결정성·멱등성이 깨지지 않도록 하는 가드레일

1. Replay / Backfill 정의
1-1. Replay

이미 존재했던 데이터를 동일 계약·동일 규칙으로 다시 계산하는 행위.
결과는 기존과 완전히 동일해야 함.

1-2. Backfill

과거 데이터에 새 계약 / 새 Sink 정의를 적용하여 채우는 행위.
결과는 새 계약 기준으로 결정적이어야 함.

2. SSOT 원칙 (Non-Negotiable)

2-1. SSOT는 항상 v4 Runtime 결과물(Slice)

Sink(OpenSearch)는 절대 SSOT 아님

Sink 단독 replay/backfill 금지

2-2. Replay는 계산이고, Sink는 반영이다

계산은 v4 Runtime에서만 수행

Sink는 CDC 이벤트를 받아 반영만 수행

2-3. FULL == INCREMENTAL 불변식 유지
Replay / Backfill에서도 반드시 성립해야 함.

3. Replay / Backfill 분류표
구분	목적	허용	실행 위치
Slice Replay	동일 결과 재생성	허용	v4 Runtime
ChangeSet Replay	증분 검증	허용	v4 Runtime
Sink Replay	Sink 재적재	허용	v4 Runtime → CDC
Sink-only Replay	Sink만 재생성	❌ 금지	N/A
Cross-Version Replay	비연속 version	❌ 금지	N/A
RuleSet 변경 Backfill	새 RuleSet 적용	허용	v4 Runtime
4. Replay 트리거 시나리오
4-1. 반드시 Replay가 필요한 경우

Sink(OpenSearch) 인덱스 손상/삭제

CDC 장애로 이벤트 누락

Index mapping 변경

Inverted index 규칙 변경

운영 실수로 Sink 데이터 불일치 발생

4-2. Replay가 필요 없는 경우

v4 Runtime 정상, Sink 지연만 존재

일시적 CDC 실패 후 자동 재시도 성공

동일 slice_hash로 중복 write 발생

5. Replay Execution Modes
5-1. Partial Replay (기본)

대상 범위를 명시적으로 제한해야 한다.

tenantId

entityKey (list / prefix / range 중 1개만 허용)

version range (from / to 필수)

sliceType allowlist

ruleSetRef

❌ 무제한 전체 replay 금지

5-2. Full Replay (예외적)

허용 조건:

Sink 전체 재구축

대규모 계약(backfill) 변경

절차:

Blue/Green 기준 new index 생성

v4 Runtime FULL slicing

CDC 통해 전체 재전파

alias swap

old index 보존 후 삭제

6. Replay Execution Flow (Chronological)
[Operator]
  → ReplayRequestContract
    → Replay Validator
      → v4 Runtime (slicing / changeset)
        → DynamoDB (Slice overwrite, 동일 hash)
          → DynamoDB Streams
            → CDC Dispatcher
              → Sink Adapter (OpenSearch)


중요

Sink는 항상 마지막 단계

중간 단계를 건너뛰는 replay 금지

7. Replay Request Contract (P0)

Replay 요청은 반드시 계약 형태로만 허용된다.

replayId: uuid
reason: string
tenantId: T1
scope:
  entityKeys: [product#P1, product#P2]   # OR prefix OR range
  versionRange:
    from: 40
    to: 42
  sliceTypes: [PRODUCT_CORE, PRODUCT_PRICE]
ruleSetRef: product-core@1.3.0
verifyMode: STRICT | SAMPLING | HASH_ONLY
cutlineVersion: 42


계약 미준수 시 Validator 단계에서 즉시 차단.

8. Replay Validator (필수 가드)
8-1. 필수 체크

ruleSetRef ACTIVE 상태인가

version 연속성 유지되는가

scope가 계약에 맞게 단일 형태인가

verifyMode가 replay 유형에 적합한가

cutlineVersion이 고정되었는가

8-2. 실패 시

실행 차단

로그 기록

운영자 승인 필요

9. VerifyMode 규칙 (P0)

STRICT

FULL vs INCREMENTAL 전수 비교

Full replay / 대규모 backfill 필수

SAMPLING

n% 샘플 + slice_hash 비교

중규모 partial replay

HASH_ONLY

hash 동일성만 확인

소규모 재전파

verifyMode는 ReplayRequestContract에 반드시 명시.

10. Watermark / Cutline 규칙 (P0)

Backfill은 cutlineVersion ≤ toVersion까지만 처리

cutline은 활성 포인터와 독립

cutline 이후 변경은 별도 replay로 처리

11. Retry / Throttling 규칙 (P1)

RetryPolicyContract

maxAttempts

exponential backoff

jitter

per-tenant rate limit

Throttle 발생 시 fail-open 금지
→ 대기 또는 중단만 허용

12. Poison Event & DLQ Triage (P1)

DLQ 이벤트는 반드시 다음으로 분류한다.

ContractError → 계약/코드 수정 후 replay

StorageError → 재시도

InvariantViolation → 즉시 중단 + 조사

DLQ replay는 반드시 replay_id에 연결된다.

13. Backfill 순서 규칙 (P1)

역참조(inverted index) 포함 backfill은 순서 고정.

Slice 생성/확정

Inverted index 재생성

Streams → Sink 반영

VerifyMode 기준 검증

순서 위반 시 실행 차단.

14. Idempotency & Concurrency

Replay는 동일 입력 재실행 가능

중복 CDC 이벤트 허용

Sink write는 doc_id 기반 idempotent

동일 (tenant, entityKey, version, ruleSet)는 single-flight

15. Observability & Audit

필수 로그 필드:

replay_id

reason

scope

ruleSetRef

fromVersion / toVersion

slice_hash

verifyMode

sink_result

Audit 로그는 삭제 금지.

16. Failure & Rollback Policy

Replay 중 실패 시 즉시 중단

이미 반영된 Sink write는 롤백하지 않음

재시도는 동일 replay_id로 수행

Rollback은 개념적으로 존재하지 않음.
항상 replay로 복구한다.

17. Explicit Non-Goals

자동 self-healing

부분 롤백

Sink 기준 복구

실시간 replay

18. Final Judgment

RFC-V4-004는 다음을 보장한다.

Replay / Backfill은 정상 운영 기능

SSOT는 항상 v4 Runtime

Sink는 절대 복구의 출발점이 아님

결정성은 운영 절차에서도 깨지지 않는다

이 RFC까지 포함하면 v4/v4.1 스택은:

Build → Distribute → Replay → Recover

전 과정을 사람이 실수해도 망가지지 않게 닫는다.

---

## 부록: DynamoDB 테이블 구조 및 RuleSet/Schema 저장 위치

### DynamoDB 테이블 구조

#### 1. `catalog-slices` (Single Table Design)

**목적**: Slice 데이터 저장 (Product, Brand, Category 등 모든 엔티티)

**키 구조**:
- **PK (Partition Key)**: `String`
  - Product (v2): `PRODUCT#<tenantId>#<productId>`
  - Product (v1 legacy): `<tenantId>#<productId>`
  - Brand: `BRAND#<tenantId>#<brandCode>`
  - Category: `CATEGORY#<tenantId>#<categoryCode>`
- **SK (Sort Key)**: `String`
  - Product (v2): `v<zeroPad(version)>#<SliceType>` (예: `v0000000001#CORE`)
  - Product (v1 legacy): `<version>#<SliceType>` (예: `1#CORE`)
  - Brand: `BRAND#<zeroPad(version)>` (예: `BRAND#0000000005`)
  - Category: `CATEGORY#<zeroPad(version)>`

**속성**:
- `pk` (String) - 파티션 키
- `sk` (String) - 정렬 키
- `tenantId` (String) - 테넌트 ID
- `productId` (String) - 상품 ID (Product의 경우)
- `sliceType` (String) - Slice 타입 (CORE, VARIANT, CONTENT_INDEX, POLICY, DISCOVERY)
- `version` (Number) - 버전 (Long)
- `data` (JSON) - Slice 데이터 (CoreSlice, VariantSlice 등)
- `hash` (String) - Slice 해시 (멱등성 검증용)
- `createdAt` (Number) - 생성 시각 (Unix timestamp)

**Slice 타입**:
- `CORE` - 상품 핵심 정보
- `VARIANT` - SKU 옵션 정보
- `CONTENT_INDEX` - 콘텐츠 포인터
- `POLICY` - 판매 정책
- `DISCOVERY` - 검색용 데이터

**Query 패턴**:
1. 특정 상품의 모든 Slice: `pk = "PRODUCT#tenant1#product123"`
2. 특정 버전의 모든 Slice: `pk = "..." AND begins_with(sk, "v0000000001#")`
3. 특정 Slice 타입: `pk = "..." AND sk = "v0000000001#CORE"`

**예시 아이템**:
```json
{
  "pk": "PRODUCT#tenant1#product123",
  "sk": "v0000000001#CORE",
  "tenantId": "tenant1",
  "productId": "product123",
  "sliceType": "CORE",
  "version": 1,
  "data": {
    "tenantId": "tenant1",
    "productId": "product123",
    "version": 1,
    "title": "상품명",
    "brand": "브랜드",
    "price": 45000,
    "primarySku": "SKU001"
  },
  "hash": "sha256:abc123...",
  "createdAt": 1706179200000
}
```

---

#### 2. `catalog-pipeline` (Single Table Design)

**목적**: 파이프라인 데이터 저장 (Snapshot, ChangeSet, Status, Hash Registry)

**키 구조**:
- **PK (Partition Key)**: `TENANT#<tenantId>#PRODUCT#<productId>`
- **SK (Sort Key)**: `String`
  - `SNAPSHOT#v<zeroPad(version)>` - Canonical Snapshot (예: `SNAPSHOT#v0000000001`)
  - `CHANGESET#v<zeroPad(version)>` - ChangeSet (예: `CHANGESET#v0000000001`)
  - `STATUS` - 파이프라인 상태 포인터 (단일 레코드)
  - `HASH#<hashType>#<hashValue>` - Hash Registry (멱등성) (예: `HASH#CANONICAL#sha256:abc123...`)

**속성**:
- `pk` (String) - 파티션 키
- `sk` (String) - 정렬 키
- `entityType` (String) - 엔티티 타입: `SNAPSHOT`, `CHANGESET`, `STATUS`, `HASH`
- `tenantId` (String) - 테넌트 ID
- `productId` (String) - 상품 ID
- `version` (Number) - 버전 (Long, SNAPSHOT/CHANGESET용)
- `canonicalHash` (String) - Snapshot 해시 (SNAPSHOT용)
- `payload` (JSON) - Snapshot/ChangeSet 데이터 (작은 경우)
- `payloadLocation` (String) - S3 경로 (>=100KB인 경우)
- `currentVersion` (Number) - 현재 버전 (STATUS용)
- `pipelineState` (String) - 파이프라인 상태: `IDLE`, `BUILDING`, `READY`, `ACTIVE`, `FAILED` (STATUS용)
- `lastError` (String) - 마지막 에러 메시지 (STATUS용, nullable)
- `lastDeployedAt` (String) - 마지막 배포 시각 (ISO 8601, STATUS용, nullable)
- `registeredVersion` (Number) - 등록된 버전 (HASH용)
- `registeredAt` (String) - 등록 시각 (ISO 8601, HASH용)
- `updatedAt` (String) - 업데이트 시각 (ISO 8601)
- `gsi1pk` (String) - GSI 파티션 키
- `gsi1sk` (String) - GSI 정렬 키

**GSI (Global Secondary Index)**:
- `gsi-pipeline-state`: `(gsi1pk, gsi1sk)`
  - `gsi1pk`: `TENANT#<tenantId>#STATE#<state>` (예: `TENANT#tenant1#STATE#ACTIVE`)
  - `gsi1sk`: `PRODUCT#<productId>`
  - 용도: 상태별 조회 (운영/모니터링)

**불변식**:
- **INV-DP1**: Hash Registry Conditional Put으로 멱등성 선점 (중복/레이스에서 1개만 승자)
- **INV-DP2**: STATUS 포인터 단조 증가 (higher version wins, 버전은 절대 감소하지 않음)
- **INV-DP3**: 대형 payload (>=100KB)는 S3 externalization

**예시 아이템들**:

**STATUS 레코드**:
```json
{
  "pk": "TENANT#tenant1#PRODUCT#product123",
  "sk": "STATUS",
  "entityType": "STATUS",
  "tenantId": "tenant1",
  "productId": "product123",
  "currentVersion": 5,
  "pipelineState": "ACTIVE",
  "lastDeployedAt": "2024-01-18T12:00:00Z",
  "updatedAt": "2024-01-18T12:00:00Z",
  "gsi1pk": "TENANT#tenant1#STATE#ACTIVE",
  "gsi1sk": "PRODUCT#product123"
}
```

**HASH 레코드**:
```json
{
  "pk": "TENANT#tenant1#PRODUCT#product123",
  "sk": "HASH#CANONICAL#sha256:abc123def456...",
  "entityType": "HASH",
  "registeredVersion": 5,
  "registeredAt": "2024-01-18T12:00:00Z"
}
```

**CHANGESET 레코드**:
```json
{
  "pk": "TENANT#tenant1#PRODUCT#product123",
  "sk": "CHANGESET#v0000000005",
  "entityType": "CHANGESET",
  "tenantId": "tenant1",
  "productId": "product123",
  "version": 5,
  "fromVersion": 4,
  "toVersion": 5,
  "changeType": "UPDATE",
  "changedKeys": ["title", "price"],
  "changedPaths": ["/title", "/price"],
  "impactedSlices": ["CORE", "DISCOVERY"],
  "payloadHash": "sha256:xyz789...",
  "createdAt": "2024-01-18T12:00:00Z"
}
```

---

### RuleSet 및 Schema 저장 위치

**중요**: RuleSet과 Schema는 **DynamoDB가 아닌 PostgreSQL**에 저장됩니다.

#### RuleSet 저장 위치

- **서비스**: `catalog-registry-service` (별도 서비스)
- **데이터베이스**: PostgreSQL (`catalog-registry-service` DB)
- **테이블**: `policy_registry`
- **용도**: Policy 정의 중앙 관리 (Transform, Validation, Enrichment 등)
- **저장 내용**:
  - Policy 정의 (JSON)
  - Policy 타입 (TRANSFORM, VALIDATION, ENRICHMENT, FILTER, AGGREGATION)
  - 의존성 정보 (entity_dependencies, policy_dependencies)
  - 버전 관리 (SemVer)
  - 상태 관리 (DRAFT, ACTIVE, DEPRECATED, ARCHIVED)

**참고**: RFC-101 원칙에 따라 "Policy가 SSOT"입니다.

#### Schema 저장 위치

- **데이터베이스**: PostgreSQL (메인 DB)
- **테이블**: `schema_registry`
- **용도**: 스키마 버전 관리 및 호환성 검증 (Confluent Schema Registry 패턴)
- **저장 내용**:
  - Entity 스키마 (JSON Schema 형식)
  - 필드 메타데이터 (field_count, required_fields, searchable_fields)
  - 버전 관리 (Semantic Version)
  - 상태 관리 (DRAFT, ACTIVE, DEPRECATED, ARCHIVED)
  - `schema_uri` (Registry가 계산한 URI, SSOT)

**참고**: `schema_registry` 테이블은 RFC-IMPL-009에 따라 Ingestion 스키마 검증/호환성 체크에 사용됩니다.

---

### 데이터 흐름 요약

```
[Raw Product Document]
    ↓
[Schema Registry] (PostgreSQL schema_registry) - 스키마 검증
    ↓
[RuleSet Registry] (catalog-registry-service DB policy_registry) - 변환 규칙 로드
    ↓
[Canonical Snapshot] (DynamoDB catalog-pipeline)
    ↓
[ChangeSet] (DynamoDB catalog-pipeline)
    ↓
[Slice Compilation] (RuleSet 기반)
    ↓
[Slice Storage] (DynamoDB catalog-slices)
    ↓
[Active Version] (PostgreSQL active_version)
    ↓
[Outbox] (PostgreSQL) - 이벤트 발행
    ↓
[Search Index] (OpenSearch)
```

---

### 주요 설계 원칙

1. **Single Table Design (DynamoDB)**: 관련 엔티티를 하나의 테이블에 통합
2. **SSOT (Single Source of Truth)**: 각 데이터는 하나의 저장소에서만 관리
3. **멱등성**: Hash Registry로 중복 방지
4. **Optimistic Locking**: 버전 기반 동시성 제어
5. **Versioning**: 모든 데이터는 버전 관리
6. **Contract-First**: RuleSet과 Schema는 계약으로 관리되며, 런타임은 이를 기계적으로 집행
