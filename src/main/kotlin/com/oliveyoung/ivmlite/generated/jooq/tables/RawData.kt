/*
 * This file is generated by jOOQ.
 */
package com.oliveyoung.ivmlite.generated.jooq.tables


import com.oliveyoung.ivmlite.generated.jooq.Public
import com.oliveyoung.ivmlite.generated.jooq.indexes.IDX_RAW_DATA_CREATED
import com.oliveyoung.ivmlite.generated.jooq.indexes.IDX_RAW_DATA_SCHEMA
import com.oliveyoung.ivmlite.generated.jooq.indexes.IDX_RAW_DATA_TENANT_ENTITY
import com.oliveyoung.ivmlite.generated.jooq.keys.RAW_DATA_IDEMPOTENT_KEY
import com.oliveyoung.ivmlite.generated.jooq.keys.RAW_DATA_PKEY
import com.oliveyoung.ivmlite.generated.jooq.keys.SLICES__SLICES_SOURCE_RAW_ID_FKEY
import com.oliveyoung.ivmlite.generated.jooq.tables.Slices.SlicesPath
import com.oliveyoung.ivmlite.generated.jooq.tables.records.RawDataRecord

import java.time.OffsetDateTime
import java.util.UUID

import kotlin.collections.Collection
import kotlin.collections.List

import org.jooq.Condition
import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Index
import org.jooq.InverseForeignKey
import org.jooq.JSONB
import org.jooq.Name
import org.jooq.Path
import org.jooq.PlainSQL
import org.jooq.QueryPart
import org.jooq.Record
import org.jooq.SQL
import org.jooq.Schema
import org.jooq.Select
import org.jooq.Stringly
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl


/**
 * RawData 레코드 저장소 (RFC-IMPL-003)
 */
@Suppress("UNCHECKED_CAST")
open class RawData(
    alias: Name,
    path: Table<out Record>?,
    childPath: ForeignKey<out Record, RawDataRecord>?,
    parentPath: InverseForeignKey<out Record, RawDataRecord>?,
    aliased: Table<RawDataRecord>?,
    parameters: Array<Field<*>?>?,
    where: Condition?
): TableImpl<RawDataRecord>(
    alias,
    Public.PUBLIC,
    path,
    childPath,
    parentPath,
    aliased,
    parameters,
    DSL.comment("RawData 레코드 저장소 (RFC-IMPL-003)"),
    TableOptions.table(),
    where,
) {
    companion object {

        /**
         * The reference instance of <code>public.raw_data</code>
         */
        val RAW_DATA: RawData = RawData()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<RawDataRecord> = RawDataRecord::class.java

    /**
     * The column <code>public.raw_data.id</code>. UUID PK
     */
    val ID: TableField<RawDataRecord, UUID?> = createField(DSL.name("id"), SQLDataType.UUID.nullable(false).defaultValue(DSL.field(DSL.raw("uuid_generate_v4()"), SQLDataType.UUID)), this, "UUID PK")

    /**
     * The column <code>public.raw_data.tenant_id</code>. 테넌트 식별자
     */
    val TENANT_ID: TableField<RawDataRecord, String?> = createField(DSL.name("tenant_id"), SQLDataType.VARCHAR(64).nullable(false), this, "테넌트 식별자")

    /**
     * The column <code>public.raw_data.entity_key</code>. 엔티티 키 (예:
     * product-123)
     */
    val ENTITY_KEY: TableField<RawDataRecord, String?> = createField(DSL.name("entity_key"), SQLDataType.VARCHAR(256).nullable(false), this, "엔티티 키 (예: product-123)")

    /**
     * The column <code>public.raw_data.version</code>. 버전 (monotonic
     * increasing)
     */
    val VERSION: TableField<RawDataRecord, Long?> = createField(DSL.name("version"), SQLDataType.BIGINT.nullable(false), this, "버전 (monotonic increasing)")

    /**
     * The column <code>public.raw_data.schema_id</code>. 스키마 ID (예: product.v1)
     */
    val SCHEMA_ID: TableField<RawDataRecord, String?> = createField(DSL.name("schema_id"), SQLDataType.VARCHAR(128).nullable(false), this, "스키마 ID (예: product.v1)")

    /**
     * The column <code>public.raw_data.schema_version</code>. 스키마 버전 (SemVer)
     */
    val SCHEMA_VERSION: TableField<RawDataRecord, String?> = createField(DSL.name("schema_version"), SQLDataType.VARCHAR(32).nullable(false), this, "스키마 버전 (SemVer)")

    /**
     * The column <code>public.raw_data.content_hash</code>.
     * SHA256(canonicalized content)
     */
    val CONTENT_HASH: TableField<RawDataRecord, String?> = createField(DSL.name("content_hash"), SQLDataType.VARCHAR(64).nullable(false), this, "SHA256(canonicalized content)")

    /**
     * The column <code>public.raw_data.content</code>. JSON 컨텐츠
     */
    val CONTENT: TableField<RawDataRecord, JSONB?> = createField(DSL.name("content"), SQLDataType.JSONB.nullable(false), this, "JSON 컨텐츠")

    /**
     * The column <code>public.raw_data.created_at</code>. 생성 시각
     */
    val CREATED_AT: TableField<RawDataRecord, OffsetDateTime?> = createField(DSL.name("created_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false).defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)), this, "생성 시각")

    private constructor(alias: Name, aliased: Table<RawDataRecord>?): this(alias, null, null, null, aliased, null, null)
    private constructor(alias: Name, aliased: Table<RawDataRecord>?, parameters: Array<Field<*>?>?): this(alias, null, null, null, aliased, parameters, null)
    private constructor(alias: Name, aliased: Table<RawDataRecord>?, where: Condition?): this(alias, null, null, null, aliased, null, where)

    /**
     * Create an aliased <code>public.raw_data</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>public.raw_data</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>public.raw_data</code> table reference
     */
    constructor(): this(DSL.name("raw_data"), null)

    constructor(path: Table<out Record>, childPath: ForeignKey<out Record, RawDataRecord>?, parentPath: InverseForeignKey<out Record, RawDataRecord>?): this(Internal.createPathAlias(path, childPath, parentPath), path, childPath, parentPath, RAW_DATA, null, null)

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    open class RawDataPath : RawData, Path<RawDataRecord> {
        constructor(path: Table<out Record>, childPath: ForeignKey<out Record, RawDataRecord>?, parentPath: InverseForeignKey<out Record, RawDataRecord>?): super(path, childPath, parentPath)
        private constructor(alias: Name, aliased: Table<RawDataRecord>): super(alias, aliased)
        override fun `as`(alias: String): RawDataPath = RawDataPath(DSL.name(alias), this)
        override fun `as`(alias: Name): RawDataPath = RawDataPath(alias, this)
        override fun `as`(alias: Table<*>): RawDataPath = RawDataPath(alias.qualifiedName, this)
    }
    override fun getSchema(): Schema? = if (aliased()) null else Public.PUBLIC
    override fun getIndexes(): List<Index> = listOf(IDX_RAW_DATA_CREATED, IDX_RAW_DATA_SCHEMA, IDX_RAW_DATA_TENANT_ENTITY)
    override fun getPrimaryKey(): UniqueKey<RawDataRecord> = RAW_DATA_PKEY
    override fun getUniqueKeys(): List<UniqueKey<RawDataRecord>> = listOf(RAW_DATA_IDEMPOTENT_KEY)

    private lateinit var _slices: SlicesPath

    /**
     * Get the implicit to-many join path to the <code>public.slices</code>
     * table
     */
    fun slices(): SlicesPath {
        if (!this::_slices.isInitialized)
            _slices = SlicesPath(this, null, SLICES__SLICES_SOURCE_RAW_ID_FKEY.inverseKey)

        return _slices;
    }

    val slices: SlicesPath
        get(): SlicesPath = slices()
    override fun `as`(alias: String): RawData = RawData(DSL.name(alias), this)
    override fun `as`(alias: Name): RawData = RawData(alias, this)
    override fun `as`(alias: Table<*>): RawData = RawData(alias.qualifiedName, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): RawData = RawData(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): RawData = RawData(name, null)

    /**
     * Rename this table
     */
    override fun rename(name: Table<*>): RawData = RawData(name.qualifiedName, null)

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Condition?): RawData = RawData(qualifiedName, if (aliased()) this else null, condition)

    /**
     * Create an inline derived table from this table
     */
    override fun where(conditions: Collection<Condition>): RawData = where(DSL.and(conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(vararg conditions: Condition?): RawData = where(DSL.and(*conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Field<Boolean?>?): RawData = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(condition: SQL): RawData = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String): RawData = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg binds: Any?): RawData = where(DSL.condition(condition, *binds))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): RawData = where(DSL.condition(condition, *parts))

    /**
     * Create an inline derived table from this table
     */
    override fun whereExists(select: Select<*>): RawData = where(DSL.exists(select))

    /**
     * Create an inline derived table from this table
     */
    override fun whereNotExists(select: Select<*>): RawData = where(DSL.notExists(select))
}
