package com.oliveyoung.ivmlite.tooling.codegen

import com.oliveyoung.ivmlite.shared.domain.errors.DomainError
import org.yaml.snakeyaml.Yaml
import java.io.File

/**
 * Entity Schema Contract → Kotlin 엔티티 빌더 코드 생성기
 * 
 * Contract YAML 파일에서 타입 세이프한 엔티티 빌더를 자동 생성합니다.
 * 
 * @example 실행
 * ```bash
 * ./gradlew generateEntities
 * ```
 * 
 * @example 생성 결과
 * ```kotlin
 * // Entities.kt
 * object Entities {
 *     val Product = EntityRef<ProductBuilder>("PRODUCT")
 *     val Brand = EntityRef<BrandBuilder>("BRAND")
 * }
 * 
 * // ProductBuilder.kt
 * class ProductBuilder : EntityBuilder {
 *     var sku: String by required()
 *     var name: String by required()
 *     var price: Long by required()
 *     var salePrice: Long? = null
 *     ...
 * }
 * ```
 */
object EntityCodeGen {
    private val yaml = Yaml()
    
    /**
     * Contract YAML에서 Entity 코드 생성
     */
    fun generate(
        contractsDir: File,
        outputDir: File,
        packageName: String = "com.oliveyoung.ivmlite.sdk.schema.generated"
    ): GenerationResult {
        val entitySchemas = scanEntitySchemas(contractsDir)
        if (entitySchemas.isEmpty()) {
            return GenerationResult(
                success = false,
                message = "No ENTITY_SCHEMA contracts found in ${contractsDir.path}",
                generatedFiles = emptyList()
            )
        }
        
        val generatedFiles = mutableListOf<File>()
        
        // 1. Entities.kt 생성
        val entitiesCode = generateEntitiesObject(entitySchemas, packageName)
        val entitiesFile = File(outputDir, packageName.replace('.', '/') + "/Entities.kt")
        entitiesFile.parentFile.mkdirs()
        entitiesFile.writeText(entitiesCode)
        generatedFiles.add(entitiesFile)
        
        // 2. 각 엔티티 빌더 생성
        entitySchemas.forEach { schema ->
            val builderCode = generateEntityBuilder(schema, packageName)
            val builderFile = File(outputDir, packageName.replace('.', '/') + "/${schema.entityType.capitalize()}Builder.kt")
            builderFile.writeText(builderCode)
            generatedFiles.add(builderFile)
        }
        
        return GenerationResult(
            success = true,
            message = "Generated ${generatedFiles.size} files from ${entitySchemas.size} entity schemas",
            generatedFiles = generatedFiles
        )
    }
    
    private fun scanEntitySchemas(dir: File): List<EntitySchemaInfo> {
        if (!dir.exists()) return emptyList()
        
        return dir.walkTopDown()
            .filter { it.isFile && (it.extension == "yaml" || it.extension == "yml") }
            .mapNotNull { file -> parseEntitySchema(file) }
            .toList()
    }
    
    private fun parseEntitySchema(file: File): EntitySchemaInfo? {
        val content = try {
            yaml.load<Map<String, Any>>(file.readText())
        } catch (e: Exception) {
            throw DomainError.ContractError("Failed to parse YAML file ${file.path}: ${e.message}")
        }
        
        val kind = content["kind"] as? String
        if (kind == null || kind != "ENTITY_SCHEMA") {
            return null
        }
        
        val id = content["id"] as? String
            ?: throw DomainError.ContractError("Missing 'id' field in ${file.path}")
        
        val entityType = content["entityType"] as? String
            ?: throw DomainError.ContractError("Missing 'entityType' field in ${file.path}")
        
        val version = content["version"]?.toString() ?: "1.0.0"
        
        @Suppress("UNCHECKED_CAST")
        val fieldsRaw = content["fields"] as? List<Map<String, Any>>
            ?: throw DomainError.ContractError("Missing 'fields' in ${file.path}")
        
        val fields = fieldsRaw.map { fieldMap ->
            FieldInfo(
                name = fieldMap["name"] as? String
                    ?: throw DomainError.ContractError("Missing field 'name' in ${file.path}"),
                type = fieldMap["type"] as? String ?: "string",
                required = fieldMap["required"] as? Boolean ?: false,
                default = fieldMap["default"],
                description = fieldMap["description"] as? String ?: ""
            )
        }
        
        return EntitySchemaInfo(
            id = id,
            entityType = entityType,
            version = version,
            fields = fields,
            sourceFile = file.path
        )
    }
    
    private fun generateEntitiesObject(schemas: List<EntitySchemaInfo>, packageName: String): String {
        return buildString {
            appendLine("// AUTO-GENERATED FILE - DO NOT EDIT")
            appendLine("// Generated by EntityCodeGen from Contract YAML files")
            appendLine("// Regenerate with: ./gradlew generateEntities")
            appendLine()
            appendLine("package $packageName")
            appendLine()
            appendLine("import com.oliveyoung.ivmlite.sdk.schema.EntityRef")
            appendLine()
            appendLine("/**")
            appendLine(" * Auto-generated Entity references from Contract YAML")
            appendLine(" * ")
            appendLine(" * @example")
            appendLine(" * ```kotlin")
            appendLine(" * Ivm.client().ingest(Entities.Product) {")
            appendLine(" *     sku = \"SKU-001\"")
            appendLine(" *     name = \"비타민C\"")
            appendLine(" *     price = 15000")
            appendLine(" * }.deploy()")
            appendLine(" * ```")
            appendLine(" */")
            appendLine("object Entities {")
            appendLine()
            
            schemas.forEach { schema ->
                val builderName = "${schema.entityType.capitalize()}Builder"
                appendLine("    /**")
                appendLine("     * ${schema.entityType} 엔티티")
                appendLine("     * ")
                appendLine("     * - ID: ${schema.id}")
                appendLine("     * - Version: ${schema.version}")
                appendLine("     * - Source: ${schema.sourceFile}")
                appendLine("     */")
                appendLine("    val ${schema.entityType.capitalize()} = EntityRef<$builderName>(")
                appendLine("        entityType = \"${schema.entityType}\",")
                appendLine("        builderFactory = { $builderName() }")
                appendLine("    )")
                appendLine()
            }
            
            appendLine("    /** All entity references */")
            appendLine("    val all: List<EntityRef<*>> = listOf(")
            schemas.forEachIndexed { index, schema ->
                val comma = if (index < schemas.size - 1) "," else ""
                appendLine("        ${schema.entityType.capitalize()}$comma")
            }
            appendLine("    )")
            appendLine()
            appendLine("    /** Find entity by type */")
            appendLine("    fun find(entityType: String): EntityRef<*>? = all.find { it.entityType == entityType }")
            appendLine("}")
        }
    }
    
    private fun generateEntityBuilder(schema: EntitySchemaInfo, packageName: String): String {
        val className = "${schema.entityType.capitalize()}Builder"
        val requiredFields = schema.fields.filter { it.required }
        val optionalFields = schema.fields.filter { !it.required }
        
        return buildString {
            appendLine("// AUTO-GENERATED FILE - DO NOT EDIT")
            appendLine("// Generated by EntityCodeGen")
            appendLine()
            appendLine("package $packageName")
            appendLine()
            appendLine("import com.oliveyoung.ivmlite.sdk.schema.EntityBuilder")
            appendLine("import com.oliveyoung.ivmlite.sdk.dsl.markers.IvmDslMarker")
            appendLine()
            appendLine("/**")
            appendLine(" * ${schema.entityType} 엔티티 빌더")
            appendLine(" * ")
            appendLine(" * @example")
            appendLine(" * ```kotlin")
            appendLine(" * Ivm.client().ingest(Entities.${schema.entityType.capitalize()}) {")
            requiredFields.take(3).forEach { field ->
                appendLine(" *     ${field.name} = ${getExampleValue(field)}")
            }
            appendLine(" * }.deploy()")
            appendLine(" * ```")
            appendLine(" */")
            appendLine("@IvmDslMarker")
            appendLine("class $className : EntityBuilder {")
            appendLine()
            appendLine("    override val entityType: String = \"${schema.entityType}\"")
            appendLine()
            
            // 필수 필드
            if (requiredFields.isNotEmpty()) {
                appendLine("    // ===== 필수 필드 =====")
                appendLine()
                requiredFields.forEach { field ->
                    appendLine("    /** ${field.description} */")
                    appendLine("    var ${field.name}: ${toKotlinType(field.type, false)} = ${getDefaultValue(field, false)}")
                    appendLine()
                }
            }
            
            // 선택 필드
            if (optionalFields.isNotEmpty()) {
                appendLine("    // ===== 선택 필드 =====")
                appendLine()
                optionalFields.forEach { field ->
                    appendLine("    /** ${field.description} */")
                    val defaultVal = if (field.default != null) {
                        getDefaultLiteral(field)
                    } else {
                        "null"
                    }
                    appendLine("    var ${field.name}: ${toKotlinType(field.type, true)} = $defaultVal")
                    appendLine()
                }
            }
            
            // 커스텀 속성
            appendLine("    // ===== 커스텀 속성 =====")
            appendLine()
            appendLine("    private val _attributes = mutableMapOf<String, Any>()")
            appendLine()
            appendLine("    /** 커스텀 속성 설정 */")
            appendLine("    fun attribute(key: String, value: Any) {")
            appendLine("        _attributes[key] = value")
            appendLine("    }")
            appendLine()
            
            // build() 메서드
            appendLine("    // ===== Build =====")
            appendLine()
            appendLine("    override fun build(): Map<String, Any?> {")
            appendLine("        // 필수 필드 검증")
            requiredFields.forEach { field ->
                val check = when {
                    field.type == "string" -> "${field.name}.isBlank()"
                    else -> "false"
                }
                if (field.type == "string") {
                    appendLine("        require(${field.name}.isNotBlank()) { \"${field.name} is required\" }")
                }
            }
            appendLine()
            appendLine("        return mapOf(")
            schema.fields.forEachIndexed { index, field ->
                val comma = if (index < schema.fields.size - 1 || true) "," else ""
                appendLine("            \"${field.name}\" to ${field.name}$comma")
            }
            appendLine("        ) + _attributes")
            appendLine("    }")
            appendLine("}")
        }
    }
    
    private fun toKotlinType(type: String, nullable: Boolean): String {
        val baseType = when {
            type == "string" -> "String"
            type == "int" -> "Int"
            type == "long" -> "Long"
            type == "boolean" -> "Boolean"
            type == "double" -> "Double"
            type.startsWith("list<") -> {
                val innerType = type.removePrefix("list<").removeSuffix(">")
                "List<${toKotlinType(innerType, false)}>"
            }
            type.startsWith("map<") -> "Map<String, Any>"
            else -> "Any"
        }
        return if (nullable) "$baseType?" else baseType
    }
    
    private fun getDefaultValue(field: FieldInfo, nullable: Boolean): String {
        if (nullable) return "null"
        return when (field.type) {
            "string" -> "\"\""
            "int" -> "0"
            "long" -> "0L"
            "boolean" -> "false"
            "double" -> "0.0"
            else -> if (field.type.startsWith("list<")) "emptyList()" else "null"
        }
    }
    
    private fun getDefaultLiteral(field: FieldInfo): String {
        val default = field.default ?: return "null"
        return when (field.type) {
            "string" -> "\"$default\""
            "int" -> "$default"
            "long" -> "${default}L"
            "boolean" -> "$default"
            "double" -> "$default"
            else -> "null"
        }
    }
    
    private fun getExampleValue(field: FieldInfo): String {
        return when (field.type) {
            "string" -> "\"example\""
            "int" -> "0"
            "long" -> "0L"
            "boolean" -> "true"
            else -> "..."
        }
    }
    
    private fun String.capitalize(): String = 
        replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
}

/**
 * Entity Schema 정보
 */
data class EntitySchemaInfo(
    val id: String,
    val entityType: String,
    val version: String,
    val fields: List<FieldInfo>,
    val sourceFile: String
)

/**
 * 필드 정보
 */
data class FieldInfo(
    val name: String,
    val type: String,
    val required: Boolean,
    val default: Any?,
    val description: String
)

// ===== CLI Entry Point =====

/**
 * CLI로 실행 가능
 */
fun main(args: Array<String>) {
    val contractsDir = args.findArg("--contracts") ?: "src/main/resources/contracts"
    val outputDir = args.findArg("--output") ?: "build/generated/kotlin"
    val packageName = args.findArg("--package") ?: "com.oliveyoung.ivmlite.sdk.schema.generated"
    
    println("EntityCodeGen - Contract → Kotlin Entity Builder Generator")
    println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    println("Contracts: $contractsDir")
    println("Output:    $outputDir")
    println("Package:   $packageName")
    println()
    
    val result = EntityCodeGen.generate(
        contractsDir = File(contractsDir),
        outputDir = File(outputDir),
        packageName = packageName
    )
    
    if (result.success) {
        println("✅ ${result.message}")
        result.generatedFiles.forEach { println("   → ${it.path}") }
    } else {
        println("❌ ${result.message}")
        System.exit(1)
    }
}

private fun Array<String>.findArg(name: String): String? {
    val index = indexOf(name)
    return if (index >= 0 && index < size - 1) get(index + 1) else null
}
